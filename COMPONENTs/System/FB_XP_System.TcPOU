<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_XP_System" Id="{a2607510-4e40-4c54-a16b-95c49a8c18da}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'no_explicit_call' := 'Do not call the body - Stick to OOP'}
(* XPlanar System - 1 per associated XPlanar 
	The system is the container and organizer for all subsequent XPlanar objects. All objects are registered with this system*)
FUNCTION_BLOCK FB_XP_System EXTENDS FB_CH_Object IMPLEMENTS I_XP_System_Registration, I_XP_System_PLC
VAR	
	{attribute 'hide'}
	bInitDone : BOOL;
	{attribute 'hide'}
	bErrorDuringFbInit : BOOL; // Not possible to reset
	{attribute 'hide'}                   	
	eActiveCommand 		: CHALET_Nc.E_NcAxisCommands := CHALET_Nc.E_NcAxisCommands.None;
	{attribute 'hide'}
    fbMovers     : FB_CH_List;
	{attribute 'hide'}	
    fbTracks     : FB_CH_List;
	{attribute 'hide'}	
	fbStations 	 : FB_CH_List;
	{attribute 'hide'}	
	fbTriggers 	 : FB_CH_List;
	{attribute 'hide'}	
	fbZones 	 : FB_CH_List;
	{attribute 'hide'}	
    ipGroup       : I_XP_Group;
	{attribute 'hide'}	
    ipEnvironment : I_XP_Environment;
	{attribute 'hide'}
    nSeqEnabling  : UINT;
	{attribute 'hide'}
	nSeqJoiningTrack : UINT;
	{attribute 'hide'}
	nSeqJoiningStation : UINT;
	{attribute 'hide'}	
    nSeqDisabling  : UINT := SEQ_DONE;
	{attribute 'hide'}
	fbFeedback : FB_CH_Feedback;
	
	//ZZZ TODO this port is not fix. REad from the TcCom object
	nMETAdsPort : UINT;
END_VAR
VAR CONSTANT
	{attribute 'hide'}
	SEQ_DONE : UINT := 999;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Enable/Disable" Id="{2451d438-812a-4f5b-97ef-b4562cf8bdd8}">
      <Folder Name="Strategy" Id="{c53fd77c-5032-4971-8841-0371e41f4803}" />
    </Folder>
    <Folder Name="Initialize" Id="{db7f5e7a-e80e-4318-bc02-314b03e8e45e}" />
    <Folder Name="Interface PLC" Id="{9ec20fc2-fccf-4614-882f-228a1b0a417b}" />
    <Folder Name="Relations" Id="{99ca6b87-84d3-4869-88e5-3910779689c6}" />
    <Method Name="CheckTargetExists" Id="{223a3eae-4d4f-4f8d-b876-6654f29a9d34}" FolderPath="Interface PLC\">
      <Declaration><![CDATA[METHOD CheckTargetExists : BOOL //Return TRUE if target is existing
VAR_INPUT
	sStation	: STRING; //Group of the targed station or LUID
END_VAR
VAR
	ipEachStation : I_XP_Station_PLC;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbStations.ResetIterator();

WHILE THIS^.fbStations.HasNextObject() DO
	IF __QUERYINTERFACE(THIS^.fbStations.GetNextObject(),ipEachStation) THEN
		//Return TRUE if found
		IF (ipEachStation.TargetGroupe = sStation) OR (ipEachStation.LUID = sStation) THEN
			CheckTargetExists := TRUE;
			EXIT;
		END_IF
	END_IF
END_WHILE

THIS^.fbStations.RestoreIterator();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disable" Id="{ee25efab-b255-4913-b173-489158e77218}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Disable : I_CH_Feedback
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Disable is allways posible

THIS^.nSeqDisabling 	:= 1;
THIS^.nSeqEnabling 		:= 0;

THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Disable;
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;
		
Disable := THIS^.fbFeedback;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Disabled" Id="{fd27619c-3a6b-46ab-936f-d2083fae2cd9}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Disabled : BOOL
]]></Declaration>
      <Get Name="Get" Id="{f9169fd1-f0f7-4c80-95f1-4f277b1152e9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Disabled := nSeqDisabling = SEQ_DONE OR 
			(nSeqDisabling = 0 AND nSeqEnabling = 0);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Disabling" Id="{efc11e2f-6b34-41cf-9d0f-07ef10131559}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD PROTECTED Disabling : HRESULT
VAR
	hr : HRESULT;
	bOk : BOOL := TRUE;
	iTempMover : I_XP_Mover;
	iTempTrack : I_XP_Track;
END_VAR
VAR_INST
	hrLastCycle : HRESULT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Disabling := S_PENDING;
CASE nSeqDisabling OF
	0: // Idle
		Disabling := S_OK;
		
		
	1: // Halt movers
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				hr := GetMostSignificant(hr, iTempMover.Halt());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 20;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF	
	
		
	20: // Halting movers
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.SET.SetVelo.x = 0;
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.SET.SetVelo.y = 0;
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.SET.SetVelo.z = 0;
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.SET.SetVelo.a = 0;
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.SET.SetVelo.b = 0;
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.SET.SetVelo.c = 0;
			END_IF
		END_WHILE
		
		IF bOk THEN 
			nSeqDisabling := 30;
		END_IF	
		
	
	30: // Reset movers
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				hr := GetMostSignificant(hr, iTempMover.Reset());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 40;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		
		
		
	40: // Resetting movers
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				hr := GetMostSignificant(hr, iTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 50;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF
		
		
	50: // Disable movers
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				hr := GetMostSignificant(hr, iTempMover.Disable());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 60;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF			
		
		
	60: // Disabling movers
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				hr := GetMostSignificant(hr, iTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 61;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		


	61: // Reset track
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),iTempTrack) THEN
				hr := GetMostSignificant(hr, iTempTrack.Reset());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 62;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		
		
		
	62: // Resetting track
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),iTempTrack) THEN
				hr := GetMostSignificant(hr, iTempTrack.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 63;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF	

				
	63: // Reset group
		hr := ipGroup.Reset();
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 64;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		
		
		
	64: // Resetting group
		hr := ipGroup.Feedback.HR;
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 70;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		
		
		
		

   70: // Disable tracks
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),iTempTrack) THEN
				hr := GetMostSignificant(hr, iTempTrack.Disable());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 80;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF			
   
		
   80: // Disabling tracks
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),iTempTrack) THEN
				hr := GetMostSignificant(hr, iTempTrack.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 90;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF	
				

	90: // Disable group
		hr := ipGroup.Disable();
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 100;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF	
		
		
   100: // Disabling group
		hr := ipGroup.Feedback.HR;
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 105;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF	

		
  105: // Remove tracks from group
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),iTempTrack) THEN
				hr := GetMostSignificant(hr, iTempTrack.RemoveFromGroup());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 106;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF			
   
		
   106: // Removing tracks from group
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),iTempTrack) THEN
				bOk := bOk AND iTempTrack.PlanarTrack.MCTOPLC_STD.GroupOID = 0;
			END_IF
		END_WHILE
		
		IF bOk THEN 
			nSeqDisabling := 110;
		END_IF	
		
		
	110: // Remove movers from group
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				hr := GetMostSignificant(hr, iTempMover.RemoveFromGroup());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 120;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		
	
		
	120: // Removing movers from group
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),iTempMover) THEN
				bOk := bOk AND iTempMover.PlanarMover.MCTOPLC.STD.GroupOID = 0;
			END_IF
		END_WHILE
		
		IF bOk THEN 
			nSeqDisabling := 130;
		END_IF		
	
		
	130: // Remove envirement from group
		hr := ipEnvironment.RemoveFromGroup();
		
		IF CheckOk(hr) THEN 
			nSeqDisabling := 140;
		ELSE
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF		
		
		
   140: // Removing envirement from group
		//IF CheckOk(iEnvironment.HR) OR (iEnvironment.Self.MCTOPLC_STD.GroupOID = 0) THEN 
		hr := ipEnvironment.Feedback.HR;
	
		IF CheckOk(hr) THEN 
			nSeqDisabling := SEQ_DONE;
		ELSIF FAILED(hr) THEN
			nSeqDisabling := 1000 + nSeqDisabling;
		END_IF	
		
	
   SEQ_DONE: //Done
   		Disabling := S_OK;

		
	1000..1999://Error
		hr := GetMostSignificant(hrLastCycle, E_FAIL);

END_CASE

//store last information
hrLastCycle := hr;

// Propagate error
IF FAILED(hr) THEN
	Disabling := hr;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{e95e6af7-4dbd-40c1-afa6-c67c54a73f5f}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Enable : CHALET_BaseComponents.I_CH_Feedback
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Done THEN
	//Error active/not ready
	THIS^.fbFeedback.LastCommandAccepted 	:= FALSE;

ELSIF nSeqEnabling <> 0 THEN
	//System is partial or full enabled. Disable first.
	THIS^.fbFeedback.LastCommandAccepted 	:= FALSE;
ELSE
	THIS^.nSeqDisabling 	:= 0;
	THIS^.nSeqEnabling 		:= 1;
	
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Enable;
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;	
END_IF

Enable := THIS^.fbFeedback;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Enabled" Id="{b69b4e92-053a-428a-883f-6f1474660dc8}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Enabled : BOOL
]]></Declaration>
      <Get Name="Get" Id="{b375f38a-3df0-44c2-b753-05b299d192e6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Enabled := nSeqEnabling = SEQ_DONE;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Enabling" Id="{04f7966e-dab8-43ee-a4cf-a4f6293acf5b}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD PROTECTED Enabling : HRESULT
VAR
	hr : HRESULT;
	bWatchDogActive : BOOL;
	
	ipTempMover : I_XP_Mover;
	ipTempMoverPlc : I_XP_Mover_PLC;
	ipTempStation : I_XP_Station;
	ipTempTrack : I_XP_Track;
	
	lrCRotationShortestPos : LREAL;
	
	nSupSeq : UINT;
END_VAR

VAR_INST
	fbTimeOutSeq : TON; 
	hrLastCycle 	: HRESULT;
	nlastState	: UINT;
	
	{attribute 'hide'}	
	fbTimeOutEnabling : FB_TcAlarm;
	{attribute 'hide'}	
	fbErrorEnabling : FB_TcAlarm;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Enabling := S_PENDING;
CASE nSeqEnabling OF
	0: // Idle
		Enabling := S_OK;	
		
	1: //Redetect all movers on real system
		bWatchDogActive := TRUE;
		IF THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetOperationMode() = OperationMode.Normal THEN
			THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).SetStartMoverRedetection();	
		END_IF
		nSeqEnabling := 5;

		
	5: //Compare detectet and expectet movers	
	   //timeout is monitored in this sequence
		bWatchDogActive := TRUE;
		IF (THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4220Detected = THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4220Expected AND
			THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4221Detected = THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4221Expected AND
			THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4330Detected = THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4330Expected AND
			THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4550Detected = THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().APM4550Expected AND
			THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().TotalDetected   = THIS^.ipEnvironment.UtilityEnvirement.XpuTcIo(1).GetMoverDetectionInfos().TotalExpected 	
		   )THEN
			nSeqEnabling := 20;
		END_IF	
			
		
		
	20: // Reset movers
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Reset());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 21;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF		
			
	21: // Resetting movers
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 30;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF

		
		
	30: // Configure environment
		bWatchDogActive := TRUE;
		hr := ipEnvironment.Configure();
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 31;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	

	31: // Configuring environment
		bWatchDogActive := TRUE;
		hr := ipEnvironment.Feedback.HR;
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 50;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF
		
		
	50: //Deside if or if not add enviroment to group
		bWatchDogActive := TRUE;
		IF XPlanarParameterlist.B_ADD_ENVIROMENT_TO_GROUP THEN
			nSeqEnabling := 51;
		ELSE
			nSeqEnabling := 70;
		END_IF
		
	51: // Add environment to group
		bWatchDogActive := TRUE;
		hr := ipEnvironment.AddToGroup(ipGroup);
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 52;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF		

	52: // Adding environment to group
		bWatchDogActive := TRUE;
		hr := ipEnvironment.Feedback.HR;
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 70;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF

		
	70: // Configure the tracks |
		bWatchDogActive := TRUE;
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipTempTrack) THEN
				hr := GetMostSignificant(hr, ipTempTrack.Configure());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 71;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	71: // Configuring the tracks 
		bWatchDogActive := TRUE;
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipTempTrack) THEN
				hr := GetMostSignificant(hr, ipTempTrack.Configuring());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 80;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
		
	80: // Enable the tracks
		bWatchDogActive := TRUE;
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipTempTrack) THEN
				hr := GetMostSignificant(hr, ipTempTrack.Enable());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 81;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF		

	81: // Enabling the tracks
		bWatchDogActive := TRUE;
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipTempTrack) THEN
				hr := GetMostSignificant(hr, ipTempTrack.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 90;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
		
	90: // Add tracks to group
		bWatchDogActive := TRUE;
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipTempTrack) THEN
				hr := GetMostSignificant(hr, ipTempTrack.AddToGroup(ipGroup));
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 91;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	

	91: // Adding tracks to group
		bWatchDogActive := TRUE;
		THIS^.fbTracks.ResetIterator();
		WHILE THIS^.fbTracks.HasNextObject() DO
			IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipTempTrack) THEN
				hr := GetMostSignificant(hr, ipTempTrack.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 100;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF		
			
		
		
	100..199: // Config Station
	(* All stations are always active to the same step to ensure that all data is available in the next step.
	   The following 100 steps are defined in the station. This makes overwriting easier *)
	   
		bWatchDogActive := TRUE;
		nSupSeq := nSeqEnabling - 100;
		THIS^.fbStations.ResetIterator();
		WHILE THIS^.fbStations.HasNextObject() DO
			IF ToXpStation(THIS^.fbStations.GetNextObject(),ipTempStation) THEN
				//Call this Methode whith seq 0->99, and wait each step until S_OK is returned. Call agaiin on S_Pending
				hr := GetMostSignificant(hr, ipTempStation.Configure(nSupSeq));
			END_IF
		END_WHILE	   
	   
	   
	   	IF CheckOk(hr) AND nSupSeq >= 99 THEN
			//All steps done 
			nSeqEnabling := 210;
		ELSIF FAILED(hr) THEN
			//Error
			nSeqEnabling := 1000 + nSeqEnabling;
		ELSIF CheckOk(hr) THEN 	 
			//active step is done, continous with next
			nSeqEnabling := nSeqEnabling + 1;
		END_IF	



	210: // Enable movers
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Enable());
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 211;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	211: // Enabling movers
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 220;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		

	220: //Rotate A-Axis to zero
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.MoveA(0));
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 221;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	221: //Rotating A-Axis to Zero	
		bWatchDogActive := TRUE;		
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 222;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	222: //Rotate B-Axis to zero
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.MoveB(0));
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 223;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	223: //Rotating B-Axis to zero
		bWatchDogActive := TRUE;			
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 230;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF		
		
				
		
	230: //Rotate C-Axis to "Zero" (to the next 90 degree pitch)
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				// Decide which 90 degree pitch is closer to the current position. If the remainder is greater than 45 degrees, then round up to the next 90 degree division.
				lrCRotationShortestPos := LREAL_TO_DINT(ipTempMover.PlanarMover.MCTOPLC.SET.SetPos.C / 90.0) * 90.0;
				hr := GetMostSignificant(hr, ipTempMover.MoveC(	fPosition		:= lrCRotationShortestPos, 
																additionalTurns := 0,
																direction		:= Tc3_Mc3Definitions.MC_DIRECTION.mcDirectionShortestWay));
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 231;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	231: //Rotating C-Axis to Zero		
		bWatchDogActive := TRUE;	
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 240;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
			
		
		
	240: // Add movers to group
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.AddToGroup(THIS^.ipGroup));
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 241;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
	
	241: // Adding mover to group
		bWatchDogActive := TRUE;
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipTempMover) THEN
				hr := GetMostSignificant(hr, ipTempMover.Feedback.HR);
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 300;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF		
	
		
		
	300: // Enable group
		bWatchDogActive := TRUE;
		hr := ipGroup.Enable();
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 310;
		ELSE
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	310: // Enabling group
		bWatchDogActive := TRUE;
		hr := ipGroup.Feedback.HR;
		
		IF CheckOk(hr) THEN 
			nSeqEnabling := 400;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	

		
		
		
	400: (*	Restart of the sequenze "JoiningTrack". Default strategy is that each mover joins the closest track
			Outsourced to a method for easier overwriting *)
		THIS^.nSeqJoiningTrack := 0;	
		nSeqEnabling := 401;	

	401: (*	Default strategy is that each mover joins the closest track
			Outsourced to a method for easier overwriting *)
		hr := THIS^.JoiningTrack();

		IF CheckOk(hr) THEN 
			nSeqEnabling := 500;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	
		
	

	
	500: (*	Restart of the sequenze "JoiningStation" to distribute the movers to the available stations.
			Outsourced to a method for easier overwriting *)
		THIS^.nSeqJoiningStation := 0;	
		nSeqEnabling := 501;	
	
	501: (*	Distribute the movers to the available stations.
		 	Outsourced to a method for easier overwriting *)
		hr := THIS^.JoiningStation();

		IF CheckOk(hr) THEN 
			nSeqEnabling := SEQ_DONE;
		ELSIF FAILED(hr) THEN
			nSeqEnabling := 1000 + nSeqEnabling;
		END_IF	


		
		
	SEQ_DONE: // Done
		Enabling := S_OK;

		
	1000..1999://Error
		hr := GetMostSignificant(hrLastCycle, E_FAIL);
		//Only rais if timeout is not active
		IF NOT fbErrorEnabling.bRaised AND NOT fbTimeOutEnabling.bRaised THEN 
			fbErrorEnabling.CreateEx(stEventEntry:=TC_EVENTS.CHALET_XPlanar_Events.ErrorEnabling, ipSourceInfo := THIS^.fbSourceInfo, bWithConfirmation := FALSE);
			fbErrorEnabling.ipArguments.AddUInt(nSeqEnabling-1000);
			fbErrorEnabling.Raise(0);
		END_IF
END_CASE


//Timeout after to long stay in one of the following seq.
fbTimeOutSeq.IN := (nlastState = nSeqEnabling) AND bWatchDogActive;
fbTimeOutSeq.PT := T#5S;
fbTimeOutSeq();
nlastState := nSeqEnabling;

IF fbTimeOutSeq.Q THEN
	IF NOT fbTimeOutEnabling.bRaised THEN 
		fbTimeOutEnabling.CreateEx(stEventEntry:=TC_EVENTS.CHALET_XPlanar_Events.TimeOutEnabling, ipSourceInfo := THIS^.fbSourceInfo, bWithConfirmation := FALSE);
		fbTimeOutEnabling.ipArguments.AddUInt(nSeqEnabling);
		fbTimeOutEnabling.Raise(0);
	END_IF
	//next seq is error
	nSeqEnabling := 1000 + nSeqEnabling;
END_IF

//Clear Tc3-Eventlogger alarm 
IF nSeqEnabling <= SEQ_DONE THEN
	fbTimeOutEnabling.Clear(0,0);
	fbErrorEnabling.Clear(0,0);
END_IF


//store last information
hrLastCycle := hr;

// Propagate error
IF FAILED(hr) THEN
	Enabling := hr;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="Enviroment" Id="{ca66a7f7-5b7a-4531-9b6f-35cff54c7ac7}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Enviroment : I_XP_Environment]]></Declaration>
      <Get Name="Get" Id="{5d63ccdd-caf8-4c4f-8f32-e86e54e02b8a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Enviroment := THIS^.ipEnvironment;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{99a8553c-1794-4a13-b55a-c788d9332b3c}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	METAdsPort : UINT; 
END_VAR
VAR
	fbGetCurTaskIdx  : GETCURTASKINDEX;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.nMETAdsPort := METAdsPort;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Feedback" Id="{10eb58e3-c35a-47ee-a75d-dc8749c15338}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Feedback : CHALET_BaseComponents.I_CH_Feedback]]></Declaration>
      <Get Name="Get" Id="{a2877983-13f9-461a-9bf0-5e19f76a8861}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Feedback := THIS^.fbFeedback;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Initialize" Id="{3262c212-f368-4a07-bc8f-6cc1bfe8381e}" FolderPath="Initialize\">
      <Declaration><![CDATA[METHOD Initialize : HRESULT
VAR_INPUT
END_VAR
VAR
	hr 				: HRESULT := S_OK;
	ipEachStation 	: I_XP_Station;
END_VAR
VAR_INST
	//This error cannot be reset. Requires a reset cold
	{attribute 'hide'}	
	fbInitError : FB_TcAlarm;
	{attribute 'hide'}	
	fbMissingInterfaceAlarm : FB_TcAlarm;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 					:= CHALET_NC.E_NcAxisCommands.Initialize;
THIS^.fbFeedback.LastCommandAccepted	:= TRUE;		
THIS^.fbFeedback.Busy 					:= TRUE;


//Check Error during FB_Init
IF THIS^.bErrorDuringFbInit THEN
	IF NOT fbInitError.bRaised THEN 
		//This error cannot be reset. Requires a reset cold
		fbInitError.CreateEx(stEventEntry:=TC_EVENTS.CHALET_XTS_Events.ErrorFBinit, ipSourceInfo := THIS^.fbSourceInfo, bWithConfirmation := FALSE);
		fbInitError.Raise(0);
	END_IF
	Initialize:= E_FAIL;
	THIS^.fbFeedback.HR := Initialize;
	RETURN;
END_IF	


//Check if Envirement and Group is existing
IF THIS^.ipEnvironment = 0 OR THIS^.ipGroup = 0  THEN
	IF NOT fbMissingInterfaceAlarm.bRaised THEN 
		//This error cannot be reset. Requires a reset cold
		fbMissingInterfaceAlarm.CreateEx(stEventEntry:=TC_EVENTS.CHALET_XTS_Events.InitializationInvalideParameter, ipSourceInfo := THIS^.fbSourceInfo, bWithConfirmation := FALSE);
		fbMissingInterfaceAlarm.Raise(0);
	END_IF
	Initialize := E_FAIL;
	THIS^.fbFeedback.HR := Initialize;
	RETURN;
END_IF


//Init envirement first to get access to XPlanar_Utility
IF THIS^.ipEnvironment.Initialize() = S_OK THEN
	hr := GetMostSignificant(hr, THIS^.ipGroup.Initialize());
	hr := GetMostSignificant(hr, THIS^.fbMovers.Initialize());
	hr := GetMostSignificant(hr, THIS^.fbTracks.Initialize());
	hr := GetMostSignificant(hr, THIS^.fbStations.Initialize());
	hr := GetMostSignificant(hr, THIS^.fbTriggers.Initialize());
	hr := GetMostSignificant(hr, THIS^.fbZones.Initialize());
ELSE
	hr := S_PENDING;
END_IF	



THIS^.bInitDone := (hr = S_OK);

Initialize:= hr;

THIS^.fbFeedback.HR := Initialize;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Initialized" Id="{a891181a-e71a-408f-87ec-edd891d0ca81}" FolderPath="Initialize\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Initialized : BOOL]]></Declaration>
      <Get Name="Get" Id="{5470c166-a85b-4990-9295-4cf8f753ede6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Initialized := bInitDone;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="JoiningStation" Id="{4fa665dd-9345-45c6-aa28-793a9d6da29f}" FolderPath="Enable/Disable\Strategy\">
      <Declaration><![CDATA[METHOD PROTECTED JoiningStation : HRESULT
VAR
	hr : HRESULT;
	ipEachMover : I_XP_Mover;
	ipEachMoverPlc : I_XP_Mover_PLC;
	ipEachMoverInStation : I_XP_Mover;
	ipEachStation : I_XP_Station;
	ipFirstStation : I_XP_Station;
	ipParentStation : I_XP_Station;
	ipTempMoverPlc : I_XP_Mover_PLC;
	
	//during move on track
	fVelo, fAccDec	: Tc3_Mc3Definitions.MC_LREAL := Tc3_Mc3Definitions.MC_DEFAULT;
END_VAR
VAR_INST
	{attribute 'hide'}	
	fbDelayJoiningStation : TON;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nSeqJoiningStation OF

	0: //Init
		fbDelayJoiningStation.IN := FALSE;
		nSeqJoiningStation := 10;
	
		
	10:	//Distribute the movers to the available stations.
		(*Send the movers to the last assigned station:
		  For this purpose, the list of assigned movers is checked at each station and the mover is given a new move command to the station.
		  If there are still movers in the system that do not have a move command, these are sent to station 1. Typically after starting up
		  *)
		
		//Do for each mover in a station
		THIS^.fbStations.ResetIterator();    
		WHILE THIS^.fbStations.HasNextObject() DO
			ToXpStation(THIS^.fbStations.GetNextObject(),ipEachStation);
				//Do for all in station assigned Movers
				ipEachStation.AssignedMovers.ResetIterator();
				WHILE ipEachStation.AssignedMovers.HasNextObject() DO
					ToXpMover(ipEachStation.AssignedMovers.GetNextObject(),ipEachMoverInStation);
					//Send to assigned station - Shortest way
					hr := GetMostSignificant(hr, ipEachMoverInStation.MoveOnTrack_ShortestWay(ipTrack	:= ipEachStation.AccocietedTrack, 
																							  fPosition	:= ipEachStation.PositionOnTrack,
																							  fGap 		:= ipEachMoverInStation.LastCmdTargedGap));
				END_WHILE
		END_WHILE        
		nSeqJoiningStation := 20;
		
	20:	//Test if there is an Mover whitout an active TargedStation (first startup)
		//Send them to first station
		THIS^.fbStations.ResetIterator();
		IF THIS^.fbStations.HasNextObject() THEN
			//Get interface to first Station in list
			ToXpStation(THIS^.fbStations.GetNextObject(),ipFirstStation);
			//Set as targed station the first station in list. but as the parent the station in front of the first one(if existing) 
			//(the parent station is not necessarily the target station. But the station that is responsible for sending the mover forward if necessary)
			ipFirstStation.StationsAhead.ResetIterator();
			ToXpStation(ipFirstStation.StationsAhead.GetNextObject(),ipParentStation);
			
			//Check for mover whitout a targed station
			THIS^.fbMovers.ResetIterator();
			WHILE THIS^.fbMovers.HasNextObject() DO
				//Do for all Movers whitout a targed station
				IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipEachMover) AND_THEN (ipEachMover.TargetStation = '') AND_THEN __QUERYINTERFACE(ipEachMover,ipEachMoverPlc) THEN
					//Set Path dynamic constraint to settings in XPlanarParameterlist. 0=Defalt
					IF XPlanarParameterlist.F_ENABLING_ON_TRACK_VELOCITY <> 0 THEN fVelo := XPlanarParameterlist.F_ENABLING_ON_TRACK_VELOCITY;END_IF
					IF XPlanarParameterlist.F_ENABLING_ON_TRACK_ACC_DEC <> 0 THEN fAccDec := XPlanarParameterlist.F_ENABLING_ON_TRACK_ACC_DEC;END_IF
				
					//Increase or decrease the mover DynConstraint for approaching the station 
					ipEachMoverPlc.SetDynConstraint_Path(	V:= fVelo, 
															A:= fAccDec, 
															D:= fAccDec, 
															J:= Tc3_Mc3Definitions.MC_DEFAULT);
		
					//Set as targed station the first station in list. but as the parent the station in front of the first one(if existing) 
					IF ipParentStation <> 0 THEN
						hr := GetMostSignificant(hr, ipEachMover.MoveOnTrackToStation(ipParentStation, XPlanarParameterlist.F_GAP_STARTUP));
						hr := GetMostSignificant(hr, ipParentStation.AddMoverToQueue(ipEachMover));
						ipEachMover.TargetStation := ipFirstStation.TargetGroupe;
					ELSE
						//If no partent station is existing
						hr := GetMostSignificant(hr, ipEachMover.MoveOnTrackToStation(ipFirstStation, XPlanarParameterlist.F_GAP_STARTUP));
						hr := GetMostSignificant(hr, ipFirstStation.AddMoverToQueue(ipEachMover));
						ipEachMover.TargetStation := ipFirstStation.TargetGroupe;
					END_IF
					
					
					//Set Path dynamic constraint back to default
					ipEachMoverPlc.SetDynConstraint_Path(	V:= Tc3_Mc3Definitions.MC_DEFAULT, 
															A:= Tc3_Mc3Definitions.MC_DEFAULT, 
															D:= Tc3_Mc3Definitions.MC_DEFAULT, 
															J:= Tc3_Mc3Definitions.MC_DEFAULT);
		
				END_IF
			END_WHILE
		END_IF

		nSeqJoiningStation := 30;
		
	30: //Delay to allow the movers to start movement
		fbDelayJoiningStation.IN := TRUE;
		fbDelayJoiningStation.PT := T#2S;
		IF fbDelayJoiningStation.Q THEN
			nSeqJoiningStation := 40;
			fbDelayJoiningStation.IN := FALSE;
		END_IF
	
	
	40: //Wait for all movers until the movement is completed(speed =0)
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipEachMover) THEN
				//Check all movers if an error is active
				IF ipEachMover.Feedback.Error THEN
					hr := GetMostSignificant(hr, ipEachMover.Feedback.HR);
				//Wait for all movers to stop/finish movement
				ELSIF NOT (ipEachMover.PlanarMover.MCTOPLC.SETONTRACK.SetVelo = 0.0) THEN
					hr := GetMostSignificant(hr, S_PENDING);
				END_IF
			END_IF
		END_WHILE
		
		IF CheckOk(hr) THEN 
			nSeqJoiningStation := SEQ_DONE;
		ELSIF FAILED(hr) THEN
			nSeqJoiningStation := 1000 + nSeqJoiningStation;
		END_IF			

	
	1000..1999://Error
		hr := GetMostSignificant(hr, E_FAIL);
END_CASE

//Update
fbDelayJoiningStation();


//Return value
IF FAILED(hr) THEN 
	//Error
    JoiningStation := GetMostSignificant(hr, E_FAIL);
ELSIF (nSeqJoiningStation = SEQ_DONE) THEN
	//Done
    JoiningStation := S_OK;
ELSE
	//Busy
    JoiningStation := S_PENDING;;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="JoiningTrack" Id="{fda71eec-2b79-4428-a838-a55feb6f1d1f}" FolderPath="Enable/Disable\Strategy\">
      <Declaration><![CDATA[METHOD PROTECTED JoiningTrack : HRESULT
VAR	
	hr : HRESULT;
	ipClosestTrack : I_XP_Track;	
	ipEachMover : I_XP_Mover;
	ipEachTrack : I_XP_Track;
	fDistance : LREAL;
	fShortestDistance : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nSeqJoiningTrack OF

	0: //Init
		nSeqJoiningTrack := 10;
	
		
	
	10:// Join closest track
		THIS^.fbMovers.ResetIterator();
		WHILE THIS^.fbMovers.HasNextObject() DO
			IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipEachMover) THEN
				
				//check all track to decide which is the closest
				THIS^.fbTracks.ResetIterator();
				//start with the greatest possible distance, so that each track is definitely closer
				fShortestDistance := CHALET_BaseComponents.GVL_Datatypes.cMaxLreal; 
				WHILE THIS^.fbTracks.HasNextObject() DO
					IF ToXpTrack(THIS^.fbTracks.GetNextObject(),ipEachTrack) THEN
						fDistance := ipEachMover.DistToTrack(ipEachTrack);
						//closer track found
						IF fDistance <= fShortestDistance THEN
							ipClosestTrack := ipEachTrack;
							fShortestDistance := fDistance;
						END_IF
					END_IF
				END_WHILE
				
				//send mover to found closest track
				IF ipClosestTrack <> 0 THEN
					hr := GetMostSignificant(hr, ipEachMover.JoinTrack(ipClosestTrack));
				ELSE
					hr := GetMostSignificant(hr, E_FAIL);
				END_IF
			END_IF
		END_WHILE
		nSeqJoiningTrack := 20;
		
		
	20: // Joining closest track check feedback
		IF NOT fbTracks.IsEmpty THEN
			THIS^.fbMovers.ResetIterator();
			WHILE THIS^.fbMovers.HasNextObject() DO
				IF ToXpMover(THIS^.fbMovers.GetNextObject(),ipEachMover) THEN
					
					// Check mover errors
					hr := GetMostSignificant(hr, ipEachMover.Feedback.HR);
					
					//Check if Mover is on track
					IF NOT (ipEachMover.Mode = MC_PLANAR_MOVER_COMMAND_MODE.OnTrack) THEN
						hr := GetMostSignificant(hr, S_PENDING);
					END_IF
				END_IF
			END_WHILE
		END_IF
		
		IF CheckOk(hr) THEN 
			nSeqJoiningTrack := SEQ_DONE;
		ELSIF FAILED(hr) THEN
			nSeqJoiningTrack := 1000 + nSeqJoiningTrack;
		END_IF			

		
	1000..1999://Error
		hr := GetMostSignificant(hr, E_FAIL);
END_CASE

		
		
//Return value
IF FAILED(hr) THEN 
	//Error
    JoiningTrack := GetMostSignificant(hr, E_FAIL);
ELSIF (nSeqJoiningTrack = SEQ_DONE) THEN
	//Done
    JoiningTrack := S_OK;
ELSE
	//Busy
    JoiningTrack := S_PENDING;;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="LinkEnvironment" Id="{e3e6b307-7100-4acf-9a20-6b55338c22ae}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD LinkEnvironment : HRESULT
VAR_INPUT
	ipEnvironment : I_CH_Object;
END_VAR

VAR
	ipXpEnvironment : I_XP_Environment;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipEnvironment <> 0 AND_THEN __QUERYINTERFACE(ipEnvironment,ipXpEnvironment) THEN
	THIS^.ipEnvironment := ipXpEnvironment;
ELSE
	LinkEnvironment := E_FAIL;
	THIS^.bErrorDuringFbInit := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="LinkGroup" Id="{f42e5cf6-1b67-41a1-a56c-a4287630fa5d}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD LinkGroup : HRESULT
VAR_INPUT
	ipGroup : I_CH_Object;
END_VAR

VAR
	ipXpGroup : I_XP_Group;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipGroup <> 0 AND_THEN __QUERYINTERFACE(ipGroup,ipXpGroup) THEN
	THIS^.ipGroup := ipXpGroup;
ELSE
	LinkGroup := E_FAIL;
	THIS^.bErrorDuringFbInit := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="METAdsPort" Id="{89ae55d7-58b0-488a-b2b5-f6d0b5ffd761}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY METAdsPort : UINT
]]></Declaration>
      <Get Name="Get" Id="{ce0da1c5-21cc-40f8-ba98-2194b3870dfa}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[METAdsPort := nMETAdsPort;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Movers" Id="{9353d17a-03c8-4198-a8d5-5b1dd965a722}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Movers : CHALET_BaseComponents.I_CH_LIST]]></Declaration>
      <Get Name="Get" Id="{3f7bd63c-d5b5-4194-a039-323cdf7b0c6c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Movers := THIS^.fbMovers;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="RegisterMover" Id="{2e69d638-c086-4ae4-a258-bab7ab9bb527}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD RegisterMover : HRESULT
VAR_INPUT
	ipMover : I_CH_Object;
END_VAR

VAR
	ipXpMover : I_XP_Mover;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipMover = 0 THEN
	//Invalide interface	
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterMover := E_FAIL;
	
ELSIF NOT __QUERYINTERFACE(ipMover, ipXpMover) THEN
	//The required interface is missing
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterMover := E_FAIL;
	
ELSIF THIS^.fbMovers.IsFull THEN
	//List is full
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterMover := E_FAIL;
	
ELSIF THIS^.bInitDone THEN
	//To late. System is initilized
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterMover := E_FAIL;
	
ELSE
	
	THIS^.fbMovers.AddObject(ipMover);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RegisterStation" Id="{f8f1897a-d3d1-4789-9a47-6742d72f08e3}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD RegisterStation : HRESULT
VAR_INPUT
	ipStation : I_CH_Object;
END_VAR

VAR
	ipXpStation : I_XP_Station;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipStation = 0 THEN
	//Invalide interface	
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterStation := E_FAIL;
	
ELSIF NOT __QUERYINTERFACE(ipStation, ipXpStation) THEN
	//The required interface is missing
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterStation := E_FAIL;
	
ELSIF THIS^.fbStations.IsFull THEN
	//List is full
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterStation := E_FAIL;
	
ELSIF THIS^.bInitDone THEN
	//To late. System is initilized
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterStation := E_FAIL;
		
ELSE
	
	THIS^.fbStations.AddObject(ipStation);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RegisterTrack" Id="{5dbea948-9611-44b5-ae62-c4a553926667}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD RegisterTrack : HRESULT
VAR_INPUT
	ipTrack : I_CH_Object;
END_VAR

VAR
	ipXpTrack : I_XP_Track;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipTrack = 0 THEN
	//Invalide interface	
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrack := E_FAIL;
	
ELSIF NOT __QUERYINTERFACE(ipTrack, ipXpTrack) THEN
	//The required interface is missing
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrack := E_FAIL;
	
ELSIF THIS^.fbTracks.IsFull THEN
	//List is full
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrack := E_FAIL;
	
ELSIF THIS^.bInitDone THEN
	//To late. System is initilized
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrack := E_FAIL;
		
ELSE
	
	THIS^.fbTracks.AddObject(ipTrack);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RegisterTrigger" Id="{003a3aff-bddb-4eb1-8f04-c60117b719a3}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD RegisterTrigger : HRESULT
VAR_INPUT
	ipTrigger	: CHALET_BaseComponents.I_CH_Object;
END_VAR
VAR
	ipXpTrigger : I_Xp_Trigger;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipTrigger = 0 THEN
	//Invalide interface	
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrigger := E_FAIL;
	
ELSIF NOT __QUERYINTERFACE(ipTrigger, ipXpTrigger) THEN
	//The required interface is missing
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrigger := E_FAIL;
	
ELSIF THIS^.fbTriggers.IsFull THEN
	//List is full
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrigger := E_FAIL;
	
ELSIF THIS^.bInitDone THEN
	//To late. System is initilized
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterTrigger := E_FAIL;
		
ELSE
	
	THIS^.fbTriggers.AddObject(ipTrigger);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RegisterZone" Id="{6022b12f-ae2e-47e3-b197-1b2df06d369d}" FolderPath="Relations\">
      <Declaration><![CDATA[METHOD RegisterZone : HRESULT
VAR_INPUT
	ipZone	: CHALET_BaseComponents.I_CH_Object;
END_VAR
VAR
	ipXpsZone : I_XP_Zone;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipZone = 0 THEN
	//Invalide interface	
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterZone := E_FAIL;

ELSIF NOT __QUERYINTERFACE(ipZone, ipXpsZone) THEN
	//The required interface is missing
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterZone := E_FAIL;
	
ELSIF THIS^.fbZones.IsFull THEN
	//List is full
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterZone := E_FAIL;
	
ELSIF THIS^.bInitDone THEN
	//To late. System is initilized
	THIS^.bErrorDuringFbInit := TRUE;
	RegisterZone := E_FAIL;
		
ELSE
	
	THIS^.fbZones.AddObject(ipZone);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Station" Id="{4e4a3528-0818-40e3-8dcd-fa9a28d1a66a}" FolderPath="Interface PLC\">
      <Declaration><![CDATA[METHOD Station : I_XP_Station_PLC
VAR_INPUT
	sLUID : STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF no station was found, INTERFACE is 0 -> can generate fatal error
__QUERYINTERFACE(THIS^.fbStations.FindLUID(sLUID),Station);
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Stations" Id="{5afded3b-ad71-4d4a-b61e-394646f604db}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Stations : CHALET_BaseComponents.I_CH_LIST]]></Declaration>
      <Get Name="Get" Id="{176c07cd-46b7-40f9-b96b-a375d9ac3ed3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Stations := THIS^.fbStations;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Tracks" Id="{21d7ddf8-1285-4e47-8ca9-761f455af2bf}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Tracks : CHALET_BaseComponents.I_CH_LIST]]></Declaration>
      <Get Name="Get" Id="{53d52f84-6320-4f08-9cf8-0f1dabb11679}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Tracks := THIS^.fbTracks;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Triggers" Id="{cc2457ca-8b27-414d-a6cc-9e0c9874be8d}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Triggers : CHALET_BaseComponents.I_CH_LIST
]]></Declaration>
      <Get Name="Get" Id="{81d86faf-0487-4961-8e92-d6f84d334d73}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Triggers := THIS^.fbTriggers;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Update" Id="{0b75e97f-4147-4977-8fcf-8d66ccd43106}">
      <Declaration><![CDATA[METHOD Update : HRESULT
VAR_INPUT
END_VAR
VAR
	hr : HRESULT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Force to do an init at beginn
IF NOT THIS^.Initialized THEN
	THIS^.Initialize();
	RETURN;
END_IF

hr := S_OK;

hr := GetMostSignificant(hr, THIS^.Enabling());
hr := GetMostSignificant(hr, THIS^.Disabling());




// ********************** Set feedback depending on active command *******************************
IF THIS^.eActiveCommand <> E_NcAxisCommands.None THEN
	fbFeedback.ActiveCommand 	:= TO_STRING(THIS^.eActiveCommand);	
END_IF

CASE THIS^.eActiveCommand OF
	E_NcAxisCommands.None: 
		;

	E_NcAxisCommands.Initialize:
		fbFeedback.Busy 		:= NOT THIS^.bInitDone;
		fbFeedback.Done 		:= THIS^.bInitDone;
		fbFeedback.ErrorId 		:= 0;
		
	E_NcAxisCommands.Enable:
		fbFeedback.Busy 		:= nSeqEnabling > 0;
		fbFeedback.Done 		:= THIS^.Enabled;
		IF nSeqEnabling > 1000 THEN
			fbFeedback.ErrorId 		:= nSeqEnabling;
		END_IF
		
	E_NcAxisCommands.Disable:
		fbFeedback.Busy 		:= nSeqDisabling > 0;
		fbFeedback.Done 		:= THIS^.Disabled;
		IF nSeqDisabling > 1000 THEN
			fbFeedback.ErrorId 		:= nSeqDisabling;
		END_IF
		


	ELSE//External command in subclass
		;
END_CASE


// **********************  Stop to execute commands on .done or .error ***************************
IF fbFeedback.Done OR THIS^.fbFeedback.Error THEN
	eActiveCommand 				:= E_NcAxisCommands.None;
END_IF







hr := GetMostSignificant(hr, THIS^.fbMovers.Update());
hr := GetMostSignificant(hr, THIS^.fbTracks.Update());
hr := GetMostSignificant(hr, THIS^.fbStations.Update());
hr := GetMostSignificant(hr, THIS^.fbZones.Update());
hr := GetMostSignificant(hr, THIS^.fbTriggers.Update());
hr := GetMostSignificant(hr, THIS^.ipGroup.Update());
hr := GetMostSignificant(hr, THIS^.ipEnvironment.Update());


Update:= hr;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ValidLUID" Id="{d1c3faf6-fe00-47fc-a876-c44e4c77b66e}" FolderPath="Interface PLC\">
      <Declaration><![CDATA[//Return TRUE if unique station id is valid. if false, interfacepointer is zero -> fatal error
METHOD ValidLUID : BOOL
VAR_INPUT
	sLUID : STRING;
END_VAR
VAR
	ipStation : I_XP_Station_PLC;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ipStation := THIS^.Station(sLUID);
ValidLUID := (ipStation <> 0);]]></ST>
      </Implementation>
    </Method>
    <Property Name="Zones" Id="{796ef09e-3844-42a2-af82-f422cc25cd4f}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Zones : CHALET_BaseComponents.I_CH_LIST
]]></Declaration>
      <Get Name="Get" Id="{63e07d5f-e938-4929-8086-0f10e0731759}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Zones := THIS^.fbZones;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>