<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_XP_Track" Id="{3b47d2f9-b25f-432c-a6e7-cfeea4a711ff}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'no_explicit_call' := 'Do not call the body - Stick to OOP'}
(* XPlanar track - n per associated XPlanar. Can be instantiated as an array and/or individually
	The Planar track is a software object that represents a (virtual) one-dimensional path on the two-dimensional XPlanar stator surface. 
	Several Planar movers can be lined up and moved on this path. Collisions are prevented by keeping a preset distance between the movers. *)	
FUNCTION_BLOCK FB_XP_Track EXTENDS FB_CH_Object IMPLEMENTS I_XP_Track
VAR
	//Link to Planar-Track object
	fbTrack : MC_PlanarTrack;
	
	{attribute 'hide'}  
	bInitDone : BOOL := FALSE;
	{attribute 'hide'}               	
	fbFeedback 			: FB_XP_Feedback(ipSourceInfo := fbSourceInfo);	
	{attribute 'hide'}                   	
	eActiveCommand 		: CHALET_Nc.E_NcAxisCommands := CHALET_Nc.E_NcAxisCommands.None;
	{attribute 'hide'}
	ipXpSystem : I_XP_System_Registration;
	{attribute 'hide'}	
	nSeqConfiguring : UINT;
	{attribute 'hide'} 
	ipTracksEndAtThis : ARRAY[0..(XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1)] OF I_XP_Track;
	{attribute 'hide'} 
	ipTracksStartFromThis : ARRAY[0..(XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1)] OF I_XP_Track;
	{attribute 'hide'}  
	fbListOfStationsOnTrack : FB_CH_List;

	{attribute 'hide'}  
	bIsClosedLoop : BOOL;
	{attribute 'hide'}  
	PreviousTrackOTCIDs 	: ARRAY[0..(XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1)] OF OTCID;
	{attribute 'hide'}  
	SubsequentTrackOTCIDs 	: ARRAY[0..(XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1)] OF OTCID;
	
	{attribute 'hide'}
	fbListOfMoversOnTrack : FB_CH_List;
	{attribute 'hide'}  
	fbTracksAhead : FB_CH_List;
	{attribute 'hide'}  
	fbTracksBehinde : FB_CH_List;
	

	{attribute 'hide'}  
	fbListPathsOnThisTrack : FB_CH_List;	
	//Interface to this track in XPlanar Utility Lib
	ipUtilityTrack  : Tc3_XPlanarUtility.I_McPlanarTrack;
	
	fbHelpferStationOnEndOfThisTrack : FB_XP_Station(	ipSystem 			:= 0,
														ipAccocietedTrack 	:= (THIS^),// =closest track
														sUniqueName			:= '',
														sTargetGroup		:= '',
														nMoverQueueSize		:= 0,
														xPos				:= 0,
														yPos				:= 0);	
														
	//MC_CIRCLE_XYC_START_CENTER_END has the size of 72 byte													
	aRawGeometricElements : ARRAY[0.. XPlanarParameterlist.N_MAX_GEOMETRIC_ELEMENTS_PER_TRACK *72] OF LREAL;
	//Interface to TcComTrack ObjectId
	ipComObject : ITComObject;
END_VAR
VAR CONSTANT
	N_IDX_OFFSET_PREVIOUS_TRACK 	: UDINT := 16#050300D5; // Parameter(online) in Planar Track object
	N_IDX_OFFSET_SUBSEQUENT_TRACK 	: UDINT := 16#050300D6; // Parameter(online) in Planar Track object	
	N_IDX_OFFSET_IS_CLOSED_LOOP		: UDINT := 16#050300E1; // Parameter(online) in Planar Track object	
	N_IDX_GEOMETRIC_INFO			: UDINT := 16#050300D7; // Parameter(offline) in Planar Track object	
	GUID_MC_CIRCLE_XYC_START_CENTER_END			: GUID := Tc2_Utilities.STRING_TO_GUID(in:= 'C3BAEC31-7F05-4B2F-A9AE-F0D8872EE557');
	GUID_MC_POINT_XYC 							: GUID := Tc2_Utilities.STRING_TO_GUID(in:= '9E820E67-264A-4170-958A-0B26CA5C91FA');
	GUID_MC_LINE_XYC 							: GUID := Tc2_Utilities.STRING_TO_GUID(in:= 'B48A64D8-464F-4B39-8708-C82C1147C8B6');
END_VAR


// Planar-Feedback objects
VAR
	{attribute 'hide'} 
	fbFeedbackDisable		: MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackEnable 		: MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackAddToGrp 		: MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackRmvFromGrp 	: MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackReset 		: MC_PlanarFeedback;
END_VAR
	

	]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Enable/Disable" Id="{2b869c2e-39f8-4722-a978-478fda933277}" />
    <Folder Name="Geometric Informations" Id="{d9dfae71-a864-43d3-8e70-b94447eeedde}" />
    <Folder Name="Group" Id="{e6e14778-ea58-4882-a699-86e8e6047192}" />
    <Folder Name="XPlanarUtility" Id="{ed4e03bd-4c35-4efc-bcf7-5657486553e7}" />
    <Method Name="AddMover" Id="{4e587a4b-a2fd-42e8-8022-3b33c6b80065}">
      <Declaration><![CDATA[METHOD AddMover : HRESULT
VAR_INPUT
	ipMover : I_XP_Mover;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipMover <> 0 THEN
	AddMover := ipMover.JoinTrack(THIS^);
ELSE
	AddMover := E_FAIL;
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddToGroup" Id="{7e7a881a-5460-47b6-87d1-69a5f54b2a36}" FolderPath="Group\">
      <Declaration><![CDATA[METHOD AddToGroup : HRESULT
VAR_INPUT
	iGroup : I_XP_Group;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.AddToGroupe;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;
	
	iGroup.AddTrack(THIS^.fbTrack, THIS^.fbFeedbackAddToGrp);
	AddToGroup := S_OK;
ELSE
	AddToGroup := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF






]]></ST>
      </Implementation>
    </Method>
    <Property Name="ClosedLoop" Id="{bc7aad9c-7b6f-43f4-8dab-47f5b074584c}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY ClosedLoop : BOOL]]></Declaration>
      <Get Name="Get" Id="{f4dc2ca0-cdfd-4b16-a4e6-b8afeb5ebf80}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ClosedLoop := bIsClosedLoop;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Configure" Id="{9fcb3d34-7c7a-4018-bb61-a13ff9565f1b}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Configure : HRESULT // This is called once during system enabling
VAR_INPUT
END_VAR
VAR_INST
	{attribute 'hide'}  
	fbAlarmTrackLength0 : FB_TcAlarm;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Validate settings
IF THIS^.Length = 0 THEN
	Configure := E_FAIL;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
	IF NOT fbAlarmTrackLength0.bRaised THEN
		fbAlarmTrackLength0.CreateEx(stEventEntry:= TC_EVENTS.CHALET_XPlanar_Events.TrackLength0, bWithConfirmation := FALSE, ipSourceInfo := THIS^.fbSourceInfo);
		fbAlarmTrackLength0.Raise(0);
	END_IF
	RETURN;
ELSE
	fbAlarmTrackLength0.Clear(0,0);	
END_IF



THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Configure;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

THIS^.nSeqConfiguring := 10;
Configure := S_OK;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Configuring" Id="{e4ce3390-76b3-4d94-9c90-9caf4d048359}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Configuring : HRESULT // This is called until S_OK during system enabling
VAR
	ipEachTrackObj : I_CH_Object;
	nIdx : UDINT;
	ipTrackComObject : ITComObject;
	nParaSize : UDINT;
	pParaData : PVOID;
	hr : HRESULT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Configuring := S_PENDING;
CASE nSeqConfiguring OF
	0: // Idle
		Configuring := S_OK;
		
	10: //Start
		nSeqConfiguring := 200;
		
		
		
	200: //Read information from Track TcCom object
		//Get interface to ComObject
		FW_ObjMgr_GetObjectInstance(oid:= THIS^.OID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipTrackComObject));
	
		IF ipTrackComObject = 0 THEN
			//Error, interface not found
			nSeqConfiguring := nSeqConfiguring + 1000;	
		ELSE
			//Read array of oids PreviousTrackOTCIDs
			nParaSize := SIZEOF(THIS^.PreviousTrackOTCIDs);	pParaData := ADR(THIS^.PreviousTrackOTCIDs);
			hr := ipTrackComObject.TcGetObjPara(pid:=N_IDX_OFFSET_PREVIOUS_TRACK , nData:= nParaSize, pData:= pParaData, pgp:=0 );
			
			//Read array of oids SubsequentTrackOTCIDs
			nParaSize := SIZEOF(THIS^.SubsequentTrackOTCIDs);	pParaData := ADR(THIS^.SubsequentTrackOTCIDs);
			hr := ipTrackComObject.TcGetObjPara(pid:=N_IDX_OFFSET_SUBSEQUENT_TRACK , nData:= nParaSize, pData:= pParaData, pgp:=0 );			
			
			//Read bool CLOSED_LOOP
			nParaSize := SIZEOF(THIS^.bIsClosedLoop);	pParaData := ADR(THIS^.bIsClosedLoop);
			hr := ipTrackComObject.TcGetObjPara(pid:=N_IDX_OFFSET_IS_CLOSED_LOOP , nData:= nParaSize, pData:= pParaData, pgp:=0 );		
			FW_SafeRelease(ADR(ipTrackComObject));

			nSeqConfiguring := 300;
		END_IF
		
			
	300: // Convert SubsequentTrackOTCIDs to I_XP_Track and add to fbTracksAhead
		fbTracksAhead.Clear();
		FOR nIdx := 0 TO (XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1) DO
			//Get interface to object
			ipEachTrackObj := THIS^.ipXpSystem.Tracks.FindOID(THIS^.SubsequentTrackOTCIDs[nIdx]);
			//convert object -> I_XP_Track. If found, store in list
			IF ToXpTrack(ipEachTrackObj, ipTracksStartFromThis[nIdx]) THEN
				fbTracksAhead.AddObject(ipEachTrackObj);
				
			ELSIF THIS^.SubsequentTrackOTCIDs[nIdx] = 0 THEN
				;//No OTCID
				
			ELSE
				//Error, no track found with following oid
				nSeqConfiguring := nSeqConfiguring + 1000;	
				RETURN;;				
			END_IF
		END_FOR
		nSeqConfiguring := 301;		
	

	301: // Convert PreviousTrackOTCIDs to I_XP_Track and add to fbTracksBehinde
		fbTracksBehinde.Clear();
		FOR nIdx := 0 TO (XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1) DO
			//Get interface to object
			ipEachTrackObj := THIS^.ipXpSystem.Tracks.FindOID(THIS^.PreviousTrackOTCIDs[nIdx]);
			//convert object -> I_XP_Track. If found, store in list
			IF ToXpTrack(ipEachTrackObj, ipTracksEndAtThis[nIdx]) THEN
				fbTracksBehinde.AddObject(ipEachTrackObj);
				
			ELSIF THIS^.PreviousTrackOTCIDs[nIdx] = 0 THEN
				;//No OTCID
				
			ELSE
				//Error, no track found with following oid
				nSeqConfiguring := nSeqConfiguring + 1000;	
				RETURN;;				
			END_IF
		END_FOR			
		nSeqConfiguring := 400;

		
	400: //Configure the helper station who is located at the end of this track to improve komplex track routing
		THIS^.fbHelpferStationOnEndOfThisTrack.PositionXY.SetValuesXY(THIS^.EndPosition.x, THIS^.EndPosition.y);
		THIS^.fbHelpferStationOnEndOfThisTrack.SuppressDynamicsChange := TRUE;
		nSeqConfiguring := 999;

		
	
	999: // Done
		Configuring := S_OK;
		
	1000..1999://Error
		Configuring := E_FAIL;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Property Name="CtsMoversOnTrack" Id="{f5c92b82-fa04-4344-9678-cfae0b690dad}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY CtsMoversOnTrack : UINT]]></Declaration>
      <Get Name="Get" Id="{580fb42a-a37b-44a8-b24d-f5b908dd5d6a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.Prepare();//Prepare a list movers on this track


CtsMoversOnTrack := TO_UINT(THIS^.fbListOfMoversOnTrack.Size);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Disable" Id="{4875b69f-6e4a-44a1-86a5-68c37016194c}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Disable : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Disable;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;

	THIS^.fbTrack.Disable(fbFeedbackDisable);
	Disable := S_OK;
ELSE
	Disable := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{292d4b33-ab4e-46c1-8ee3-9dd6992332cb}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Enable : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Enable;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;

	THIS^.fbTrack.Enable(fbFeedbackEnable);
	Enable := S_OK;
ELSE
	Enable := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Property Name="EndPosition" Id="{3eee912d-154c-4b33-916a-01b4669bbc05}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Position of the end point of this tracks
PROPERTY EndPosition : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{63128c22-4f0f-4912-b653-cc8d40ba4beb}">
        <Declaration><![CDATA[VAR_INST
	stEndPositionXY : MoverVector;
END_VAR
VAR
	fbPositionXYC : PositionXYC;
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.fbTrack.GetPositionAt(THIS^.Length,fbPositionXYC);


stEndPositionXY.x := fbPositionXYC.x;
stEndPositionXY.y := fbPositionXYC.y;
stEndPositionXY.z := 0;
stEndPositionXY.a := 0;
stEndPositionXY.b := 0;
stEndPositionXY.c := fbPositionXYC.c;



EndPosition REF= stEndPositionXY;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_exit" Id="{4f01476f-79a4-4db5-92f3-0972795e9781}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FW_SafeRelease(ADR(THIS^.ipComObject));]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{bd7962a8-7fbc-4b97-8a9e-756a233bc51d}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	ipSystem : I_CH_Object;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Do the following code once during start up and not during onlinechange
IF NOT bInCopyCode THEN 
	
	(* Register to the Xplanar System
	   1. Test if the interface exists
	   2. Test if the object implements a "System for Mover" interface 
	*)
	IF ipSystem <> 0 AND_THEN __QUERYINTERFACE(ipSystem,THIS^.ipXpSystem) THEN
		THIS^.ipXpSystem.RegisterTrack(THIS^);
		
		
		THIS^.fbHelpferStationOnEndOfThisTrack.FB_init(	bInCopyCode			:= FALSE,
														bInitRetains		:= bInitRetains,
														ipSystem 			:= ipSystem,
														ipAccocietedTrack 	:= (THIS^),// =closest track
														sUniqueName			:= CONCAT('HelperStationAtEndOf', THIS^.LUID),
														sTargetGroup		:= '',
														nMoverQueueSize		:= 0,
														xPos				:= 0,
														yPos				:= 0);	
	END_IF

	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Feedback" Id="{1564402b-ab3a-4608-8e90-81f38c847303}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Feedback : I_XP_Feedback]]></Declaration>
      <Get Name="Get" Id="{f0acb3f0-6342-46be-9655-47b46b5941f5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Feedback := THIS^.fbFeedback;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="GapAtPosition" Id="{92b9e156-7ad7-46e1-9a4d-4507cbe51387}">
      <Declaration><![CDATA[(* Calculates which gap the mover should have on a position
	The gap results from the last station crossed.
	If several stations are possible ( switch), the largest gap is displayed here *)
METHOD GapAtPosition : LREAL
VAR_INPUT
	fPosOnTrack : LREAL;//[mm]	
END_VAR
VAR
	ipThisTrack : I_XP_Track := (THIS^);
	bStartAndEndIsOnThisTrack : BOOL;
	ipEachPathOnTrack : I_XP_Path;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

THIS^.fbListPathsOnThisTrack.ResetIterator();
WHILE THIS^.fbListPathsOnThisTrack.HasNextObject() DO
	IF __QUERYINTERFACE(THIS^.fbListPathsOnThisTrack.GetNextObject(), ipEachPathOnTrack) THEN
		
		IF ipEachPathOnTrack.Length > ipEachPathOnTrack.DistanceToDestiantion(fPosOnTrack := fPosOnTrack, ipTrack := ipThisTrack) THEN
			GapAtPosition := MAX(GapAtPosition, ipEachPathOnTrack.StationStart.MoverGapAtExit);
		END_IF
			
		//bStartAndEndIsOnThisTrack := ipEachPathOnTrack.StationStart.AccocietedTrack = ipThisTrack AND ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack; 
		//	
		////Check if start of route is maybe on this track
		//IF (ipEachPathOnTrack.StationStart.AccocietedTrack = ipThisTrack) AND (ipEachPathOnTrack.StationStart.PositionOnTrack > fPosOnTrack) AND NOT bStartAndEndIsOnThisTrack THEN
		//	//start is after the searched position
		//	CONTINUE;
        //
		////Check if end of route is maybe on this track
		//ELSIF (ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack) AND (ipEachPathOnTrack.StationDestination.PositionOnTrack <= fPosOnTrack) AND NOT bStartAndEndIsOnThisTrack THEN
		//	//end is befor the searched position
		//	CONTINUE;		
		//	
		////Check if in limit - CLOSED LOOP, SHORT SEGMENT Start > End
		//ELSIF F_InLimitTest(fMinimum := ipEachPathOnTrack.StationStart.PositionOnTrack, fInput:= fPosOnTrack, fMaximum := ipEachPathOnTrack.StationDestination.PositionOnTrack) AND bStartAndEndIsOnThisTrack THEN
		//	//track is outside the searched position
		//	CONTINUE;		
        //
		//	
		//ELSE
		//	//The gap is valide, use the largest one
		//	GapAtPosition := MAX(GapAtPosition, ipEachPathOnTrack.StationStart.MoverGapAtExit);
        //
		//END_IF
		
	END_IF
END_WHILE
THIS^.fbListPathsOnThisTrack.RestoreIterator();]]></ST>
      </Implementation>
    </Method>
    <Property Name="HelperStationAtEndOfTrack" Id="{e8df97fd-3383-4b86-8571-fbb8107b888c}">
      <Declaration><![CDATA[//Each track has an auxiliary station at the end of itself. This is used automatically or not, depending on whether the track also contains stations created by the user.
//These are used by the movers as auxiliary links to navigate through a complex network.
{attribute 'monitoring':='call'}
PROPERTY HelperStationAtEndOfTrack : I_XP_Station]]></Declaration>
      <Get Name="Get" Id="{c7670e4f-f7ad-4a84-923b-3c3e4ad2d39c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[HelperStationAtEndOfTrack :=  THIS^.fbHelpferStationOnEndOfThisTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Initialize" Id="{b896fc44-0b73-4eff-afae-ecb801b264e1}">
      <Declaration><![CDATA[METHOD Initialize : HRESULT
VAR
	hr : HRESULT;
	ipStation : I_XP_Station;
	stVarInfo : __SYSTEM.VAR_INFO;
	sName : STRING;
	ipTcIoXpu : I_TcIoXPlanarProcessingUnit;		
	nIdxXpu : UDINT;
	nIdxTrack : UDINT;
	ipTcIoMover: INT;
END_VAR

VAR_INST
	//This error cannot be reset. Requires a reset cold
	{attribute 'hide'}	
	fbInitError : FB_TcAlarm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Check if link to track is mapped
IF NOT THIS^.Mapped THEN
	IF NOT fbInitError.bRaised THEN 
		//This error cannot be reset. Requires a reset cold
		fbInitError.CreateEx(stEventEntry:=TC_EVENTS.CHALET_Base_Events.VariableLinkMissing, ipSourceInfo := THIS^.fbSourceInfo, bWithConfirmation := FALSE);
		stVarInfo := __VARINFO(fbTrack.MCTOPLC_STD);
		fbInitError.ipArguments.AddString(stVarInfo.Symbol);
		fbInitError.Raise(0);
	END_IF
	Initialize := E_FAIL;
	RETURN;
END_IF


IF NOT bInitDone THEN
	//Busy
	Initialize := S_PENDING;
	FW_ObjMgr_GetObjectInstance(oid:= THIS^.fbTrack.MCTOPLC_STD.TrackOID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(THIS^.ipComObject));	
	
	//TRUE = Use inside PLC the track name from the TcCom Track Object. 
	//FALSE = overwride TcCom Track object with instance name
	IF XPlanarParameterlist.B_TRACK_NAME_TACKOVER_FROM_TRACK_OBJECT THEN
		IF THIS^.ipComObject <> 0 THEN
			THIS^.ipComObject.TcGetObjectName(objName:= ADR(sName), nameLen := SIZEOF(sName));	
			THIS^.fbSourceInfo.sName := sName;
		END_IF
	ELSE
		IF THIS^.ipComObject <> 0 THEN
			sName := THIS^.LUID;
			THIS^.ipComObject.TcSetObjectName(ADR(sName));	
		END_IF
	END_IF
	
	
	//Search interface for this OID
	IF ipXpSystem.Enviroment.UtilityEnvirement <> 0 THEN
		//Get TcIo-Mover interface to utiliy lib
		FOR nIdxTrack := 1 TO Param_TcIoXPlanarEnvironment.MaxXPlanarMoversPerXpu DO
			IF ipXpSystem.Enviroment.UtilityEnvirement.P_TrackOids[nIdxTrack] = THIS^.fbTrack.MCTOPLC_STD.TrackOID THEN
				THIS^.ipUtilityTrack := ipXpSystem.Enviroment.UtilityEnvirement.McTrack(nIdxTrack);
				EXIT;
			END_IF
		END_FOR
	END_IF


	
	//Done as sone list is initilized
	bInitDone := TRUE;
	
ELSE	
	//Done
	Initialize := S_OK;	
END_IF



THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Initialize;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;	
//Set done or keep in busy state	
THIS^.fbFeedback.HR := Initialize;



]]></ST>
      </Implementation>
    </Method>
    <Property Name="Length" Id="{71eaadbd-1c54-42e9-8d1d-8f27bd48dc86}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//[mm]
PROPERTY Length : LREAL]]></Declaration>
      <Get Name="Get" Id="{a130a9f2-5c04-404e-92e9-c79382f2a810}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Length := THIS^.fbTrack.GetLength();]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Mapped" Id="{1a400ed0-2c58-4d55-9002-0c3878fabdc3}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Mapped : BOOL //Project is mapped to MC (McToPlc and PlcToMc)
]]></Declaration>
      <Get Name="Get" Id="{20c2a12e-68d3-4272-b1a0-39444f2afedd}">
        <Declaration><![CDATA[VAR
	bMcToPlcNotMapped 	: BOOL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bMcToPlcNotMapped := F_GetMappingStatus(ADR(THIS^.fbTrack.MCTOPLC_STD), SIZEOF(THIS^.fbTrack.MCTOPLC_STD)) <> EPlcMappingStatus.MS_Mapped;

Mapped := NOT bMcToPlcNotMapped;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="MoversOnTrack" Id="{50bf933d-e2cd-41f2-b1b7-c648cff042cf}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//List of interfaces to movers on this track
PROPERTY MoversOnTrack : I_CH_LIST]]></Declaration>
      <Get Name="Get" Id="{1231e818-c830-4d8f-8622-f6e0d4608729}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.Prepare();//Prepare a list movers on this track


MoversOnTrack := THIS^.fbListOfMoversOnTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="NbOfGeometricElements" Id="{f55bce07-b4ca-4664-b1cf-7cf991b412c3}" FolderPath="Geometric Informations\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
// Number of elements describing the geometric curve of the track.
PROPERTY NbOfGeometricElements : UINT]]></Declaration>
      <Get Name="Get" Id="{88f93434-2753-4ab3-bf33-fe76bb272581}">
        <Declaration><![CDATA[VAR
	nParameterSize : UDINT;
	hr : HRESULT;
	pParaData : PVOID;
	nFoundParameterSize : UDINT;
	nIdx : UDINT;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF THIS^.ipComObject = 0 THEN
	//Error invalide inteerface
	RETURN;
END_IF

//Read Parameter with an unknown size, repeat until size matches
pParaData := ADR(aRawGeometricElements);
FOR nParameterSize := 0 TO SIZEOF(aRawGeometricElements) BY SIZEOF(aRawGeometricElements[0])  DO 
	
	hr := THIS^.ipComObject.TcGetObjPara(pid:= N_IDX_GEOMETRIC_INFO , nData:= nParameterSize, pData:= pParaData, pgp:=0 );
	
	//Exit if matching size is found
	IF hr = S_OK THEN
		nFoundParameterSize := nParameterSize;
		EXIT;
	END_IF
END_FOR

IF hr <> S_OK THEN
	//Todo Error, list is not matching
	RETURN;
END_IF

//Empty list
IF nFoundParameterSize <= SIZEOF(GUID) THEN
	NbOfGeometricElements := 0;
	RETURN;
END_IF

//Count Nb of GUIDs in raw data
FOR nIdx := 0 TO (nFoundParameterSize-SIZEOF(GUID)) DO
	//Check if at the position x is a GUID of type GUID_MC_POINT_XYC
	IF (Tc2_System.MEMCMP(pBuf1:= ADR(GUID_MC_POINT_XYC), pBuf2:= ADR(aRawGeometricElements[nIdx]), n:= SIZEOF(GUID)) = 0) THEN
		NbOfGeometricElements := NbOfGeometricElements +1;
		nIdx := nIdx + 20; //Skip size of element
	ELSIF (Tc2_System.MEMCMP(pBuf1:= ADR(GUID_MC_LINE_XYC), pBuf2:= ADR(aRawGeometricElements[nIdx]), n:= SIZEOF(GUID)) = 0) THEN
		NbOfGeometricElements := NbOfGeometricElements +1;	
		nIdx := nIdx + 40; //Skip size of element	
	ELSIF (Tc2_System.MEMCMP(pBuf1:= ADR(GUID_MC_CIRCLE_XYC_START_CENTER_END), pBuf2:= ADR(aRawGeometricElements[nIdx]), n:= SIZEOF(GUID)) = 0) THEN
		NbOfGeometricElements := NbOfGeometricElements +1;		
		nIdx := nIdx + 70; //Skip size of element
	END_IF
END_FOR]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="OID" Id="{90983f23-ab27-4c9b-83fe-ad4ce837aabc}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Unique object ID
PROPERTY OID : OTCID ]]></Declaration>
      <Get Name="Get" Id="{2f957262-8fdd-45d3-9100-ac31a63822a2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[OID := THIS^.fbTrack.MCTOPLC_STD.TrackOID;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="PathsOnTrack" Id="{11d971dd-07f8-4664-bc9e-a2bf8fc67154}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//List of interfaces to paths on this track
PROPERTY PathsOnTrack : I_CH_List]]></Declaration>
      <Get Name="Get" Id="{d777e419-beeb-40dd-aa7d-7aa157846473}">
        <Declaration><![CDATA[VAR

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.Prepare();//Prepare a list stations on this track

PathsOnTrack := THIS^.fbListPathsOnThisTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="PlanarTrack" Id="{2fb9669f-5350-4c6c-81e0-7e96f15e447b}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PlanarTrack : REFERENCE TO MC_PlanarTrack]]></Declaration>
      <Get Name="Get" Id="{fa842340-3326-4a7d-8913-7ca984b2ea37}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PlanarTrack ref= THIS^.fbTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Prepare" Id="{9d189cd9-e796-449e-9a38-2edf6ad5313b}">
      <Declaration><![CDATA[(* Time-critical information is processed here, which can then be polled via the property every cycle. 
The update method is usually at the end of the program and then it is already 'outdated'. *)
METHOD PRIVATE Prepare : HRESULT
VAR
	ipThisTrack : I_XP_Track := THIS^;
	ipStation : I_XP_Station;
	ipMover : I_XP_Mover;
	ipPath : I_XP_Path;
END_VAR

VAR_INST
	{attribute 'hide'}
	nLastUpdatedCycleCount : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Check if this Cycle the dates are allready prepared
IF nLastUpdatedCycleCount <> TwinCAT_SystemInfoVarList._TaskInfo[THIS^.nTaskIndex].CycleCount THEN
	nLastUpdatedCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[THIS^.nTaskIndex].CycleCount;

	//Creat a list of all Stations on this Track
	THIS^.fbListOfStationsOnTrack.Clear();
	THIS^.ipXpSystem.StationsUsed.ResetIterator();
	WHILE THIS^.ipXpSystem.StationsUsed.HasNextObject() DO
		IF ToXpStation(THIS^.ipXpSystem.StationsUsed.GetNextObject(), ipStation) AND_THEN ipStation.AccocietedTrack <> 0 AND_THEN ipStation.AccocietedTrack = ipThisTrack THEN
			THIS^.fbListOfStationsOnTrack.AddObject(ipStation);
		END_IF
	END_WHILE
	THIS^.ipXpSystem.StationsUsed.RestoreIterator();
	
	
	
	//Creat a list of all Movers on this Track
	THIS^.fbListOfMoversOnTrack.Clear();
	THIS^.ipXpSystem.MoversPresent.ResetIterator();
	WHILE THIS^.ipXpSystem.MoversPresent.HasNextObject() DO
		IF ToXpMover(THIS^.ipXpSystem.MoversPresent.GetNextObject(), ipMover) AND_THEN ipMover.CurrentTrack <> 0 AND_THEN ipMover.CurrentTrack = ipThisTrack THEN
			THIS^.fbListOfMoversOnTrack.AddObject(ipStation);
		END_IF
	END_WHILE
	THIS^.ipXpSystem.MoversPresent.RestoreIterator();	
	
	
		
	//Creat a list of all Paths on this Track
	THIS^.fbListPathsOnThisTrack.Clear();
	THIS^.ipXpSystem.Paths.ResetIterator();
	WHILE THIS^.ipXpSystem.Paths.HasNextObject() DO
		IF __QUERYINTERFACE(THIS^.ipXpSystem.Paths.GetNextObject(), ipPath)AND_THEN __ISVALIDREF(ipPath.TracksUsed) AND_THEN ipPath.TracksUsed.ObjectInList(ipThisTrack) THEN
			THIS^.fbListPathsOnThisTrack.AddObject(ipPath);
		END_IF
	END_WHILE
	THIS^.ipXpSystem.Paths.RestoreIterator();	
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveFromGroup" Id="{9de749e7-be9a-4037-a8c7-8d2d3b16d041}" FolderPath="Group\">
      <Declaration><![CDATA[METHOD RemoveFromGroup : HRESULT
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.RemoveFromGroupe;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;
	
	THIS^.fbTrack.RemoveFromGroup(THIS^.fbFeedbackRmvFromGrp);
	
	RemoveFromGroup := S_OK;
ELSE
	RemoveFromGroup := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF






]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReplicateGeometricElements" Id="{949de8f3-2386-4c64-af06-a58d624abb64}" FolderPath="Geometric Informations\">
      <Declaration><![CDATA[//The geometric points of a track are copied. Including the position and type. This only works if the system is disabled.
METHOD ReplicateGeometricElements : HRESULT
VAR_INPUT
	ipTrackCopyFrom : I_XP_Track;
END_VAR
VAR
	ipComObjectExternalTrack  : ITComObject;
	nParameterSize : UDINT;
	hr : HRESULT;
	pParaData : PVOID;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.ipComObject = 0 OR ipTrackCopyFrom = 0 THEN
	//Error invalide interface
	ReplicateGeometricElements := E_HRESULTAdsErr.INVALIDINTERFACE;
	RETURN;
END_IF

pParaData := ADR(aRawGeometricElements);
nParameterSize := SIZEOF(aRawGeometricElements);

//Get interface to external track
hr := FW_ObjMgr_GetObjectInstance(oid:= ipTrackCopyFrom.OID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObjectExternalTrack));	

//Read Parameter from external track
IF ipComObjectExternalTrack <> 0 THEN
	hr := ipComObjectExternalTrack.TcGetObjPara(pid:= N_IDX_GEOMETRIC_INFO , nData:= nParameterSize, pData:= pParaData, pgp:=0 );
	
	//Set Parameter in this local track
	IF (hr=S_OK) THEN
		ReplicateGeometricElements := THIS^.ipComObject.TcSetObjPara(pid:= N_IDX_GEOMETRIC_INFO , nData:= nParameterSize, pData:= pParaData, pgp:=0 );
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{d67cf55e-473b-48f9-af14-d88c18e7c136}">
      <Declaration><![CDATA[METHOD Reset : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Reset;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

THIS^.fbTrack.Reset(THIS^.fbFeedbackReset);
Reset := S_OK;



]]></ST>
      </Implementation>
    </Method>
    <Method Name="ShiftTrack" Id="{94d896de-1ed1-443d-8df4-fcd8541a269b}" FolderPath="Geometric Informations\">
      <Declaration><![CDATA[//move all points of the track geometry. Only works if the system is disabled.
METHOD ShiftTrack : HRESULT
VAR_INPUT
	xOffset, yOffset : LREAL;
END_VAR
VAR
	nParameterSize : UDINT;
	hr : HRESULT;
	pParaData : PVOID;
	nFoundParameterSize : UDINT;
	nIdx : UDINT;
	nTempIndex : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.ipComObject = 0 THEN
	//Error invalide interface
	ShiftTrack := E_HRESULTAdsErr.INVALIDINTERFACE;
	RETURN;
END_IF

//Read Parameter with an unknown size, repeat until size matches
pParaData := ADR(aRawGeometricElements);
FOR nParameterSize := 0 TO SIZEOF(aRawGeometricElements) BY SIZEOF(aRawGeometricElements[0])  DO 
	
	hr := THIS^.ipComObject.TcGetObjPara(pid:= N_IDX_GEOMETRIC_INFO , nData:= nParameterSize, pData:= pParaData, pgp:=0 );
	
	//Exit if matching size is found
	IF hr = S_OK THEN
		nFoundParameterSize := nParameterSize;
		EXIT;
	END_IF
END_FOR


//List is not matching
IF hr <> S_OK THEN
	ShiftTrack := Tc2_System.E_HRESULTAdsErr.INVALIDSIZE;
	RETURN;
END_IF

//Empty list
IF nFoundParameterSize <= SIZEOF(GUID) THEN
	ShiftTrack := S_FALSE;
	RETURN;
END_IF

//Count Nb of GUIDs in raw data
FOR nIdx := 0 TO (nFoundParameterSize-SIZEOF(GUID)) DO
	//Check if at the position x is a GUID of type GUID_MC_POINT_XYC
	IF (Tc2_System.MEMCMP(pBuf1:= ADR(GUID_MC_POINT_XYC), pBuf2:= ADR(aRawGeometricElements[nIdx]), n:= SIZEOF(GUID)) = 0) THEN
		//Modify x
		nTempIndex := nIdx+ 2(*GUID*) + 0*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + xOffset;
		//Modify y
		nTempIndex := nIdx+ 2(*GUID*) + 1*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + yOffset;
		nIdx := nIdx + 3 -1; //Skip size of element
	ELSIF (Tc2_System.MEMCMP(pBuf1:= ADR(GUID_MC_LINE_XYC), pBuf2:= ADR(aRawGeometricElements[nIdx]), n:= SIZEOF(GUID)) = 0) THEN
		//Modify start x
		nTempIndex := nIdx+ 2(*GUID*) + 0*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + xOffset;
		//Modify start y
		nTempIndex := nIdx+ 2(*GUID*) + 1*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + yOffset;
		//Modify end x
		nTempIndex := nIdx+ 2(*GUID*) + 3*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + xOffset;
		//Modify end y
		nTempIndex := nIdx+ 2(*GUID*) + 4*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + yOffset;
		nIdx := nIdx + 6 -1; //Skip size of element	
	ELSIF (Tc2_System.MEMCMP(pBuf1:= ADR(GUID_MC_CIRCLE_XYC_START_CENTER_END), pBuf2:= ADR(aRawGeometricElements[nIdx]), n:= SIZEOF(GUID)) = 0) THEN
		//Modify start x
		nTempIndex := nIdx+ 2(*GUID*) + 0*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + xOffset;
		//Modify start y
		nTempIndex := nIdx+ 2(*GUID*) + 1*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + yOffset;
		//Modify end x
		nTempIndex := nIdx+ 2(*GUID*) + 3*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + xOffset;
		//Modify end y
		nTempIndex := nIdx+ 2(*GUID*) + 4*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + yOffset;
		//Modify center x
		nTempIndex := nIdx+ 2(*GUID*) + 6*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + xOffset;
		//Modify center y
		nTempIndex := nIdx+ 2(*GUID*) + 7*1(*LREAL*);
		aRawGeometricElements[nTempIndex] := aRawGeometricElements[nTempIndex] + yOffset;
		nIdx := nIdx + 9 -1; //Skip size of element
	END_IF
END_FOR


//Write new raw parameter to tccom track
pParaData := ADR(aRawGeometricElements);
ShiftTrack := THIS^.ipComObject.TcSetObjPara(pid:= N_IDX_GEOMETRIC_INFO , nData:= nFoundParameterSize, pData:= pParaData, pgp:=0 );]]></ST>
      </Implementation>
    </Method>
    <Property Name="StartPosition" Id="{29915506-1bd6-4ad9-b148-10b27e13ced7}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Position of the start point of this tracks
PROPERTY StartPosition : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{8a608550-8056-4959-9949-33edef428741}">
        <Declaration><![CDATA[VAR_INST
	stStartPositionXY : MoverVector;
END_VAR
VAR
	fbPositionXYC : PositionXYC;
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.fbTrack.GetPositionAt(0,position := fbPositionXYC);


stStartPositionXY.x := fbPositionXYC.x;
stStartPositionXY.y := fbPositionXYC.y;
stStartPositionXY.z := 0;
stStartPositionXY.a := 0;
stStartPositionXY.b := 0;
stStartPositionXY.c := fbPositionXYC.c;



StartPosition REF= stStartPositionXY;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="StationAhedPosition" Id="{b7ff30e8-52a5-4be1-97f6-04f993b8234e}">
      <Declaration><![CDATA[(* Returns the first station on current track who has exact thsi position or is ahead
	If no station on this track, result is maybe on another track*)
METHOD StationAhedPosition : I_XP_Station
VAR_INPUT
	fPosOnTrack : LREAL;//[mm]	
END_VAR
VAR
	fDistToTempBestStaton : LREAL := CHALET_BaseComponents.GVL_Datatypes.cMaxLreal;;
	ipTempBestStation : I_XP_Station;
	fDist :LREAL;
	bStartAndEndIsOnThisTrack : BOOL;
	ipThisTrack : I_XP_Track := (THIS^);
	ipEachPathOnTrack : I_XP_Path;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbListPathsOnThisTrack.ResetIterator();
WHILE THIS^.fbListPathsOnThisTrack.HasNextObject() DO
	IF __QUERYINTERFACE(THIS^.fbListPathsOnThisTrack.GetNextObject(), ipEachPathOnTrack) THEN
		
		bStartAndEndIsOnThisTrack := ipEachPathOnTrack.StationStart.AccocietedTrack = ipThisTrack AND ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack; 
		
		//Check if end of route is not before this station
		IF (ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack) AND (ipEachPathOnTrack.StationDestination.PositionOnTrack < fPosOnTrack) AND NOT bStartAndEndIsOnThisTrack THEN
			//end is before the searched position - not a valide target
			CONTINUE;		
		END_IF
		
		//Check if end of route is before this station - CLOSED LOOP, SHORT SEGMENT
		IF NOT F_InLimitTest(fMinimum := ipEachPathOnTrack.StationStart.PositionOnTrack, fInput:= fPosOnTrack, fMaximum := ipEachPathOnTrack.StationDestination.PositionOnTrack) AND bStartAndEndIsOnThisTrack THEN
			//end is before the searched position - not a valide target
			CONTINUE;		
		END_IF
	
			
		fDist := ipEachPathOnTrack.DistanceToDestiantion(	ipTrack := ipThisTrack, 
															fPosOnTrack := 	fPosOnTrack);
															
		//Get shortest distance													
		IF 	fDist <= fDistToTempBestStaton	THEN
			fDistToTempBestStaton := fDist;
			ipTempBestStation := ipEachPathOnTrack.StationDestination;
		END_IF
		
	END_IF
END_WHILE
THIS^.fbListPathsOnThisTrack.RestoreIterator();

StationAhedPosition := ipTempBestStation;]]></ST>
      </Implementation>
    </Method>
    <Method Name="StationBehindPosition" Id="{297140b3-c91d-4235-b57f-f377efcd965e}">
      <Declaration><![CDATA[(* Returns the first station on current track who has exact thsi position or is behind
	If no station on this track, result is maybe on another track*)
METHOD StationBehindPosition : I_XP_Station
VAR_INPUT
	fPosOnTrack : LREAL;//[mm]	
END_VAR
VAR
	fDistToTempBestStaton : LREAL := CHALET_BaseComponents.GVL_Datatypes.cMaxLreal;;
	ipTempBestStation : I_XP_Station;
	fDist :LREAL;
	bStartAndEndIsOnThisTrack : BOOL;
	ipThisTrack : I_XP_Track := (THIS^);
	ipEachPathOnTrack : I_XP_Path;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbListPathsOnThisTrack.ResetIterator();
WHILE THIS^.fbListPathsOnThisTrack.HasNextObject() DO
	IF __QUERYINTERFACE(THIS^.fbListPathsOnThisTrack.GetNextObject(), ipEachPathOnTrack) THEN
		
		bStartAndEndIsOnThisTrack := ipEachPathOnTrack.StationStart.AccocietedTrack = ipThisTrack AND ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack; 
		
		//Check if end of route is not before this station
		IF (ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack) AND (ipEachPathOnTrack.StationDestination.PositionOnTrack < fPosOnTrack) AND NOT bStartAndEndIsOnThisTrack THEN
			//end is before the searched position - not a valide target
			CONTINUE;		
		END_IF
		
		//Check if end of route is before this station - CLOSED LOOP, SHORT SEGMENT
		IF NOT F_InLimitTest(fMinimum := ipEachPathOnTrack.StationStart.PositionOnTrack, fInput:= fPosOnTrack, fMaximum := ipEachPathOnTrack.StationDestination.PositionOnTrack) AND bStartAndEndIsOnThisTrack THEN
			//end is before the searched position - not a valide target
			CONTINUE;		
		END_IF
	
		//Dist to Start	
		fDist := ipEachPathOnTrack.Length - ipEachPathOnTrack.DistanceToDestiantion(	ipTrack := ipThisTrack, 
																						fPosOnTrack := 	fPosOnTrack);
															
		//Get shortest distance													
		IF 	fDist <= fDistToTempBestStaton	THEN
			fDistToTempBestStaton := fDist;
			ipTempBestStation := ipEachPathOnTrack.StationDestination;
		END_IF
		
	END_IF
END_WHILE
THIS^.fbListPathsOnThisTrack.RestoreIterator();

StationBehindPosition := ipTempBestStation;]]></ST>
      </Implementation>
    </Method>
    <Method Name="StationClosestTo" Id="{17715c8f-0fa8-4d44-9e57-92ed973b8dcc}">
      <Declaration><![CDATA[(* Returns the closest station on current, ahead or behind track*)
METHOD StationClosestTo : I_XP_Station
VAR_INPUT
	fPosOnTrack : LREAL;//[mm]	
END_VAR
VAR
	fDistToTempBestStaton : LREAL := CHALET_BaseComponents.GVL_Datatypes.cMaxLreal;;
	ipTempBestStation : I_XP_Station;
	fDist :LREAL;
	bStartAndEndIsOnThisTrack : BOOL;
	ipThisTrack : I_XP_Track := (THIS^);
	ipEachPathOnTrack : I_XP_Path;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbListPathsOnThisTrack.ResetIterator();
WHILE THIS^.fbListPathsOnThisTrack.HasNextObject() DO
	IF __QUERYINTERFACE(THIS^.fbListPathsOnThisTrack.GetNextObject(), ipEachPathOnTrack) THEN
		
		bStartAndEndIsOnThisTrack := ipEachPathOnTrack.StationStart.AccocietedTrack = ipThisTrack AND ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack; 
		
		//Check if end of route is not before this station
		IF (ipEachPathOnTrack.StationDestination.AccocietedTrack = ipThisTrack) AND (ipEachPathOnTrack.StationDestination.PositionOnTrack < fPosOnTrack) AND NOT bStartAndEndIsOnThisTrack THEN
			//end is before the searched position - not a valide target
			CONTINUE;		
		END_IF
		
		//Check if end of route is before this station - CLOSED LOOP, SHORT SEGMENT
		IF NOT F_InLimitTest(fMinimum := ipEachPathOnTrack.StationStart.PositionOnTrack, fInput:= fPosOnTrack, fMaximum := ipEachPathOnTrack.StationDestination.PositionOnTrack) AND bStartAndEndIsOnThisTrack THEN
			//end is before the searched position - not a valide target
			CONTINUE;		
		END_IF
	
		//Dist to End				
		fDist := ipEachPathOnTrack.DistanceToDestiantion(	ipTrack := ipThisTrack, 
															fPosOnTrack := 	fPosOnTrack);
		//Dist to Start	
		fDist := MIN(fDist, ipEachPathOnTrack.Length - ipEachPathOnTrack.DistanceToDestiantion(	ipTrack := ipThisTrack, 
																						fPosOnTrack := 	fPosOnTrack));


															
		//Get shortest distance													
		IF 	fDist <= fDistToTempBestStaton	THEN
			fDistToTempBestStaton := fDist;
			ipTempBestStation := ipEachPathOnTrack.StationDestination;
		END_IF
		
	END_IF
END_WHILE
THIS^.fbListPathsOnThisTrack.RestoreIterator();

StationClosestTo := ipTempBestStation;]]></ST>
      </Implementation>
    </Method>
    <Property Name="StationsOnTrack" Id="{ca95f937-74e0-4a2d-ac82-7e91487478dd}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//List of interfaces to stations on this track
PROPERTY StationsOnTrack : I_CH_List]]></Declaration>
      <Get Name="Get" Id="{769e0be7-7ee5-4c9d-9d14-1c198e779f31}">
        <Declaration><![CDATA[VAR

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.Prepare();//Prepare a list stations on this track

StationsOnTrack := THIS^.fbListOfStationsOnTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="System" Id="{f15f37e0-fbd4-47cc-95b2-b22fc3a063ba}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Interface to CHALET system to which this object belongs
PROPERTY System : I_XP_System_PLC]]></Declaration>
      <Get Name="Get" Id="{047a92ef-c19f-4e3b-8184-c08487dbff88}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[//get I_x_System_PLC interface from I_x_System_Registration
__QUERYINTERFACE(THIS^.ipXpSystem, System);
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="TracksAhead" Id="{92a74ea1-3481-47a8-9934-6351bc6b2d7e}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//List of interfaces from other tracks
PROPERTY TracksAhead : I_CH_List]]></Declaration>
      <Get Name="Get" Id="{d246ae69-e060-4256-a29d-debc90cb7228}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TracksAhead := fbTracksAhead;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="TracksBehinde" Id="{be356905-91c0-4b9d-8181-4d4abe69740c}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//List of interfaces from other tracks
PROPERTY TracksBehinde : I_CH_List]]></Declaration>
      <Get Name="Get" Id="{a20b6cd6-324d-464a-8647-9c8338f041f6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TracksBehinde:= fbTracksBehinde;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="TracksEndAtThis" Id="{74b0ded5-e929-46ca-b828-5466efe653e0}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//zzz Todo Delet me
PROPERTY TracksEndAtThis : REFERENCE TO  ARRAY[0..(XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1)] OF I_XP_Track]]></Declaration>
      <Get Name="Get" Id="{e11bad87-2af8-410b-a2af-e0cb16dd4cb1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TracksEndAtThis REF= ipTracksEndAtThis;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="TracksStartFromThis" Id="{f5262a37-248e-4ded-aad1-91bd1fc5719b}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY TracksStartFromThis : REFERENCE TO ARRAY[0..(XPlanarParameterlist.N_MAX_STATIONS_AHEAD_OR_BEHIND-1)] OF I_XP_Track]]></Declaration>
      <Get Name="Get" Id="{e40e870d-64f3-414e-9693-9373335e2f88}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TracksStartFromThis REF= ipTracksStartFromThis;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Update" Id="{8a9f448d-8111-47f3-8acb-64af533cf07b}">
      <Declaration><![CDATA[METHOD PUBLIC Update : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
THIS^.Prepare();//Prepare time-critical information, if not already done



// ********************** Set feedback depending on active command *******************************
CASE THIS^.eActiveCommand OF
	E_NcAxisCommands.None: 
		//Display if a Mover Error is active during no command is active
		IF THIS^.fbTrack.Error AND NOT fbFeedback.Error THEN 
			fbFeedback.ErrorId 			:= THIS^.fbTrack.ErrorID;
			fbFeedback.ActiveCommand 	:= TO_STRING(E_NcAxisCommands.None);	
			fbFeedback.ClearObjectInfo();
		END_IF

	E_NcAxisCommands.Initialize:
		fbFeedback.Busy 			:= NOT THIS^.bInitDone;
		fbFeedback.Done 			:= THIS^.bInitDone;
		fbFeedback.ErrorId 			:= 0;
		fbFeedback.ClearObjectInfo();
		                        	
	E_NcAxisCommands.Enable:     	
		fbFeedback.Busy 			:= fbFeedbackEnable.Busy;
		fbFeedback.Done 			:= fbFeedbackEnable.Done;
		fbFeedback.ErrorId 			:= fbFeedbackEnable.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackEnable.objectInfo;
                                			                        	
	E_NcAxisCommands.Disable:     	
		fbFeedback.Busy 			:= fbFeedbackDisable.Busy;
		fbFeedback.Done 			:= fbFeedbackDisable.Done;
		fbFeedback.ErrorId 			:= fbFeedbackDisable.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackDisable.objectInfo;
		
	E_NcAxisCommands.Configure:
		fbFeedback.Busy 		:= nSeqConfiguring > 0;
		fbFeedback.Done 		:= nSeqConfiguring = 999;
		IF nSeqConfiguring > 1000 THEN
			fbFeedback.ErrorId 		:= nSeqConfiguring;
		END_IF
                                			                        	
	E_NcAxisCommands.Reset:     	
		fbFeedback.Busy 			:= fbFeedbackReset.Busy;
		fbFeedback.Done 			:= fbFeedbackReset.Done;
		fbFeedback.ErrorId 			:= fbFeedbackReset.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackReset.objectInfo;
                                      			                        	
	E_NcAxisCommands.AddToGroupe:     	
		fbFeedback.Busy 			:= fbFeedbackAddToGrp.Busy;
		fbFeedback.Done 			:= fbFeedbackAddToGrp.Done;
		fbFeedback.ErrorId 			:= fbFeedbackAddToGrp.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackAddToGrp.objectInfo;
                                      			                        	
	E_NcAxisCommands.RemoveFromGroupe:     	
		fbFeedback.Busy 			:= fbFeedbackRmvFromGrp.Busy;
		fbFeedback.Done 			:= fbFeedbackRmvFromGrp.Done;
		fbFeedback.ErrorId 			:= fbFeedbackRmvFromGrp.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackRmvFromGrp.objectInfo;
                                		
	ELSE//External command in subclass
		;
END_CASE


// **********************  Stop to execute commands on .done or .error ***************************
IF fbFeedback.Done OR THIS^.fbFeedback.Error THEN
	eActiveCommand 				:= E_NcAxisCommands.None;
END_IF

//Update xplanar object
THIS^.fbTrack.Update();

//Update feedback object
fbFeedbackEnable.Update(); 
fbFeedbackDisable.Update(); 
fbFeedbackReset.Update(); 
fbFeedbackAddToGrp.Update(); 
fbFeedbackRmvFromGrp.Update(); 
]]></ST>
      </Implementation>
    </Method>
    <Property Name="UtilityTrack" Id="{7c6756da-6b50-4c54-8f7f-c35e18a32b59}" FolderPath="XPlanarUtility\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Interface to this track in XPlanar Utility Lib
PROPERTY UtilityTrack : Tc3_XPlanarUtility.I_McPlanarTrack]]></Declaration>
      <Get Name="Get" Id="{c02674e6-d175-4a6b-b428-baf9f7b8de19}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[UtilityTrack :=  THIS^.ipUtilityTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>