<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_XP_Mover" Id="{ab327e23-c80a-4275-af5f-c83c5ee6f670}" SpecialFunc="None">
    <Declaration><![CDATA[// The warning " Interface of overridden methode xxx of base I_xxx doesn't match declaration" can be disabled here. 
{warning disable C0094 }
{attribute 'no_explicit_call' := 'Do not call the body - Stick to OOP'}
(* XPlanar mover - n per associated XPlanar. Can be instantiated as an array and/or individually
	The Planar mover is a software object that represents an XPlanar mover. It summarizes the state of the real mover (position, velocity, etc.) 
	for the user. In addition, the user has the possibility to influence or control the state of the real mover via the Planar mover. *)	
FUNCTION_BLOCK FB_XP_Mover EXTENDS FB_CH_Object IMPLEMENTS I_XP_Mover, I_XP_Mover_PLC
VAR
	fbRouteRemaining : FB_CH_List;//Remaining route to the parent station
	fbRouteComplete : FB_CH_List;//Complete route from last parent to active parent station
END_VAR

VAR
	//Link to MC-Mover
	fbMover : MC_PlanarMover; 
	
	{attribute 'hide'}  
	bInitDone :BOOL := FALSE;
	{attribute 'hide'}               	
	fbFeedback 			: FB_XP_Feedback(ipSourceInfo := fbSourceInfo);	
	{attribute 'hide'}                   	
	eActiveCommand 		: CHALET_Nc.E_NcAxisCommands := CHALET_Nc.E_NcAxisCommands.None;
	{attribute 'hide'}
	ipXpSystem : I_XP_System_Registration;
	{attribute 'hide'} 
	sTargetStation : STRING := XPlanarParameterlist.S_MOVER_TARGED_INIT;
	{attribute 'hide'} 
	sCurrentStation : STRING;
	{attribute 'hide'}
	ipParentStation : I_XP_Station; //This is the station in which the Mover is currently standing or moving.	
	{attribute 'hide'}
	ipProductData : I_XP_ProductData; //later the required interface of the tool or product can be queried via query interface
	{attribute 'hide'}	
	ipMcMover : Tc3_XPlanarUtility.I_McPlanarMover;
	{attribute 'hide'}	
	ipTcIoMover : Tc3_XPlanarUtility.I_TcIoXPlanarMover;
END_VAR

//Recovery
VAR
	{attribute 'hide'}
	stLastValidPositionXYZABC :  MoverVector;//This was the last valid (system enabled) actual  position of the mover
	{attribute 'hide'}
	//This was the last valid (system enabled) actual  position of the mover
	fLastValidPositionOnTrack :  LREAL;
	{attribute 'hide'}
	ipLastValidTrack : I_XP_Track;	//This was the last valid (system enabled) actual  position of the mover
	{attribute 'hide'}
	fLastCmdTargetPosition : LREAL; //the last commanded target position [mm]
	{attribute 'hide'}	
	fLastCmdTargetGap 	: LREAL; //the last commanded target gap
	{attribute 'hide'}		
	ipLastCmdTrack : I_XP_Track; //the last commanded target track
	{attribute 'hide'}			
	ipLastValidParentStation : I_XP_Station; //the last commanded parent station
END_VAR


//External Setpoint Generator
VAR
	AxisSetpointX : FB_NcAxis;
	AxisSetpointY : FB_NcAxis;
	AxisSetpointZ : FB_NcAxis;
	AxisSetpointA : FB_NcAxis;
	AxisSetpointB : FB_NcAxis;
	AxisSetpointC : FB_NcAxis;
	{attribute 'hide'} 
	nSeqStartExternalSetpoint : UINT;
	{attribute 'hide'} 	
	//As long as the bit is still false, the MC_PlanarFeedback should not be evaluated as it may still indicate an old error
	bEvaluateFeedback: BOOL; 
	{attribute 'hide'} 
	bFeedExternalSetpointActive : BOOL; 
	{attribute 'hide'} 
	fbFeedbackExternalSetpointStartSeq : FB_CH_Feedback(0);
	{attribute 'hide'} 
	ipMasterMover : I_XP_Mover;	
	{attribute 'hide'} 
	stMasterMovementScaling : MoverVector; // if 0, Mover is not folowing this mover axis
	{attribute 'hide'} 
	stMasterPositionAtStart : MoverVector;
END_VAR


//Unknown Level
VAR
//	{attribute 'hide'} 
	nSeqLiftFromUnknown : UINT;
//	{attribute 'hide'} 
	nSeqLowerToUnknown : UINT;	
//	{attribute 'hide'} 
	fbFeedbackLiftFromUnknown  : FB_CH_Feedback(0);
//	{attribute 'hide'} 
	fbFeedbackLowerToUnknown : FB_CH_Feedback(0);
END_VAR


//DynamicConstraint
VAR
	{attribute 'hide'} 
	fbDynConstraintContainer 	: DynamicConstraint_Container;		//A container for dynamic constraints.
	{attribute 'hide'} 
	fbDynConstraintPath 		: DynamicConstraint_PathXY; 		//One dimensional dynamic constraint along the XY-components of a path, ignoring non-tangential effects.
	{attribute 'hide'} 	
	fbDynConstraintCoordinates	: DynamicConstraint_Coordinates;	//Dynamic constraints for individual coordinates.
END_VAR


// Planar-Feedback objects
VAR
	{attribute 'hide'} 
	fbFeedbackMoveA : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackMoveB : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackMoveC : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackMoveXY : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackMoveZ : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackEnable : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackDisable : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackHalt : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackReset : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackAddToGrp : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackRmvFromGrp : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackJoinTrack : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackMoveOnTrack: MC_PlanarFeedback;	
	{attribute 'hide'} 
	fbFeedbackExtStart : MC_PlanarFeedback;
	{attribute 'hide'} 
	fbFeedbackExtStop : MC_PlanarFeedback;
END_VAR
{warning restore C0094}]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="DynamicConstraint" Id="{d445897a-09cb-4fda-a46e-ec867f4d3abd}" />
    <Folder Name="Enable/Disable" Id="{118cfbc8-9c5c-4824-939f-4f4d77b16207}" />
    <Folder Name="ExternalSetpoint" Id="{a2bf1c81-8843-4280-a370-a856ca37652a}" />
    <Folder Name="Group" Id="{15b18c0c-c114-42c6-81c4-6f4fec930060}" />
    <Folder Name="Lift/Lower" Id="{4cd918e7-4e80-40e4-995e-703fb0249362}" />
    <Folder Name="Movement" Id="{71fc6c5f-a715-4757-9cea-ae0964b87573}" />
    <Folder Name="Recovery" Id="{376c217d-78e5-45c7-a391-0a945415567e}" />
    <Folder Name="RouteToParent" Id="{076d34ec-9f7d-4b2d-bfef-132e00e090c4}" />
    <Folder Name="Status" Id="{7c319981-3d18-43ce-a6fc-e8a539b271cb}" />
    <Folder Name="Track" Id="{b9c51507-74e6-496d-bd54-4011234c577f}" />
    <Folder Name="XPlanarUtility" Id="{6265d6cf-bf94-4db5-a67a-38e99f167093}" />
    <Property Name="AccelerationSet" Id="{848c4a5f-e19a-462b-8575-2f5721a8fa88}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Provides the current planar mover setpoint XYZABC [mm/s²] *)
PROPERTY AccelerationSet : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{fcb66551-ae3e-4b26-a75a-775333b549f1}">
        <Declaration><![CDATA[VAR_INST
	{attribute 'hide'}
	copyOfData :  MoverVector;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//Creat an copy of the struct to view value in targetdbrowser and plc online view
copyOfData := THIS^.fbMover.MCTOPLC.SET.SetAcc;
AccelerationSet REF= copyOfData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="AddMoverExtSetpoint" Id="{c1212229-683f-4d57-84f7-d8318460bb0f}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[//Save the master mover and apply the distance traveled as a relative offset to this slave mover. Requires .StartExternalSetpoint()
METHOD AddMoverExtSetpoint : HRESULT
VAR_INPUT
	ipMasterMover : I_XP_Mover;
	fScalingX, fScalingY, fScalingZ, fScalingA, fScalingB, fScalingC : LREAL;// If >0, follow this axis to master-mover
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Invalide input
IF ipMasterMover = 0 THEN
	AddMoverExtSetpoint := E_FAIL;
	RETURN;
END_IF

//Allready stored a master
IF THIS^.ipMasterMover <> 0 THEN
	AddMoverExtSetpoint := E_FAIL;
	RETURN;
END_IF

//Only possible if ExternalSetpoint is not running
IF THIS^.nSeqStartExternalSetpoint <> 0 THEN
	AddMoverExtSetpoint := E_FAIL;
	RETURN;
END_IF



THIS^.ipMasterMover := ipMasterMover;
THIS^.stMasterMovementScaling.x := fScalingX;
THIS^.stMasterMovementScaling.y := fScalingy;
THIS^.stMasterMovementScaling.z := fScalingz;
THIS^.stMasterMovementScaling.a := fScalinga;
THIS^.stMasterMovementScaling.b := fScalingb;
THIS^.stMasterMovementScaling.c := fScalingc;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddToGroup" Id="{b7083e45-de51-423f-af15-898bfcfa4c12}" FolderPath="Group\">
      <Declaration><![CDATA[METHOD AddToGroup : HRESULT
VAR_INPUT
	iGroup : I_XP_Group;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.AddToGroupe;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;
	
	iGroup.AddMover(THIS^.fbMover, THIS^.fbFeedbackAddToGrp);
	AddToGroup := S_OK;
ELSE
	AddToGroup := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF






]]></ST>
      </Implementation>
    </Method>
    <Property Name="AxisExtSetpointA" Id="{fc944251-594f-4761-9835-ceaabc6ab57a}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY  AxisExtSetpointA : CHALET_Nc.I_NcAxis_PLC]]></Declaration>
      <Get Name="Get" Id="{65889034-8d62-4563-b552-b60ca4e44678}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AxisExtSetpointA := THIS^.AxisSetpointA;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="AxisExtSetpointB" Id="{16cbcef0-5066-4820-a21b-738798c4f728}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY AxisExtSetpointB : CHALET_Nc.I_NcAxis_PLC]]></Declaration>
      <Get Name="Get" Id="{215c4ac7-6b8d-4dc7-8540-5055409c9467}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AxisExtSetpointB := THIS^.AxisSetpointB;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="AxisExtSetpointC" Id="{2a314677-bf42-4814-b7ac-de0165d29bac}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY AxisExtSetpointC : CHALET_Nc.I_NcAxis_PLC]]></Declaration>
      <Get Name="Get" Id="{1c7b3025-08f7-45f5-a2c3-697a1b8882b1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AxisExtSetpointC := THIS^.AxisSetpointC;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="AxisExtSetpointX" Id="{b19dc23d-5598-48bc-9b91-bc0fe132bd2f}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY  AxisExtSetpointX : CHALET_Nc.I_NcAxis_PLC]]></Declaration>
      <Get Name="Get" Id="{8470c078-5765-4924-9750-c50ce59fbb6a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AxisExtSetpointX := THIS^.AxisSetpointX;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="AxisExtSetpointY" Id="{e695c413-25e3-4988-9728-08b568281a89}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY AxisExtSetpointY : CHALET_Nc.I_NcAxis_PLC]]></Declaration>
      <Get Name="Get" Id="{b2fc17c0-db31-4c7f-8997-35b60b657b02}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AxisExtSetpointY := THIS^.AxisSetpointY;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="AxisExtSetpointZ" Id="{639e3520-cd36-4fc2-8d78-1ebb959583f9}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY AxisExtSetpointZ : CHALET_Nc.I_NcAxis_PLC]]></Declaration>
      <Get Name="Get" Id="{467c598f-4c9e-404c-855a-9a750795db1e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AxisExtSetpointZ := THIS^.AxisSetpointZ;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CAxisModulo" Id="{b809ddda-1b0d-4b66-844c-939b67337e5d}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* C coordinate modulus set in MC3-Planar Mover[°] *)
PROPERTY CAxisModulo : LREAL]]></Declaration>
      <Get Name="Get" Id="{aa4602ce-0e13-47b5-9093-0d98f7009ea4}">
        <Declaration><![CDATA[VAR
	ipTrackComObject : ITComObject;
	nParaSize : UDINT;
	pParaData : PVOID;
	hr : HRESULT;
	fData : LREAL;
END_VAR
VAR CONSTANT
	N_IDX_OFFSET 	: UDINT := 16#05030107; // Parameter(init) Mover
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[FW_ObjMgr_GetObjectInstance(oid:= THIS^.OID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipTrackComObject));

IF ipTrackComObject = 0 THEN
	// Error
	RETURN;
END_IF


nParaSize := SIZEOF(fData);	pParaData := ADR(fData);

hr := ipTrackComObject.TcGetObjPara(pid:=N_IDX_OFFSET , nData:= nParaSize, pData:= pParaData, pgp:=0 );
FW_SafeRelease(ADR(ipTrackComObject));


CAxisModulo := TO_LREAL(TO_DINT(fData));]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CommandMode" Id="{f7143276-b906-4e49-bda1-4004ee4ca8cc}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Indicates the command mode of an enabled PlanarMover, i.e. how setpoints are currently produced. *)
PROPERTY CommandMode : MC_PLANAR_MOVER_COMMAND_MODE]]></Declaration>
      <Get Name="Get" Id="{e3e26a33-5872-4c5d-8cbf-9d667220d9a1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[CommandMode := THIS^.fbMover.MCTOPLC.STD.CommandMode;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CurrentTrack" Id="{64a558ec-5550-4dfa-a4d4-01d74944ec8a}" FolderPath="Track\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY CurrentTrack : I_XP_Track]]></Declaration>
      <Get Name="Get" Id="{5d361579-61d9-4068-8f35-769aa0c95778}">
        <Declaration><![CDATA[VAR
	ipTrackObj : I_CH_Object;
	ipTrack : I_XP_Track;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF ipXpSystem <> 0 THEN
	ipTrackObj := ipXpSystem.Tracks.FindOID(THIS^.PlanarMover.MCTOPLC.SETONTRACK.TrackOID);
	ToXpTrack(ipTrackObj,ipTrack);
END_IF

CurrentTrack := ipTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Disable" Id="{b8cb871a-a3c3-4b84-ac07-f23f90d00314}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Disable : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Disable;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

//Disable Axis
THIS^.fbMover.Disable(THIS^.fbFeedbackDisable);
Disable := S_OK;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disassemble" Id="{9007d2ab-440d-44f3-a117-b8f7b2035ba9}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[//This method is called when the system is disabled. Links are deleted as they may no longer be valid
METHOD Disassemble : HRESULT
VAR_INPUT
END_VAR

//Todo zzz Braucht es diese methode noch?]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbRouteComplete.Clear(); 
fbRouteRemaining.Clear(); 


Disassemble := S_OK;]]></ST>
      </Implementation>
    </Method>
    <Property Name="DistToParentStation" Id="{7318bf17-d807-4416-9e99-18f45b6519ca}" FolderPath="RouteToParent\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Distance to the responsible parent station [mm]
PROPERTY DistToParentStation : LREAL
]]></Declaration>
      <Get Name="Get" Id="{f210e1e2-3a19-426e-b9e1-7aab2065228e}">
        <Declaration><![CDATA[VAR
	fDistToParentStationStartup : LREAL := CHALET_BaseComponents.GVL_Datatypes.cMaxLreal;
	fDistToParentStationReturn : LREAL;
	
	
	ipPath : I_XP_Path;
	bPathFound : BOOL;
	fTempDistToDest : LREAL;
	
	refPosOnTrack : REFERENCE TO MoverVector;
	ipNextWaypoint : I_XP_Station;
	
	fTotalLength : LREAL;
	fDistToBegin : LREAL;
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF THIS^.ParentStation = 0 THEN
	DistToParentStation := CHALET_BaseComponents.GVL_Datatypes.cMaxLreal;
	RETURN;
END_IF

//--- Not on track, line 
IF THIS^.CurrentTrack = 0 THEN
	refPosOnTrack REF= THIS^.ParentStation.PositionOnTrackXYZABC;
	fDistToParentStationReturn := F_DistXYVectors(THIS^.PositionAct,refPosOnTrack);
// ---- ---- ----	


//--- at startup there is no route - parent is station ahead
ELSIF THIS^.fbRouteComplete.IsEmpty THEN
	//check each path behind the parentstation if the mover is on it
	ParentStation.PathsBehinde.ResetIterator();
	WHILE ParentStation.PathsBehinde.HasNextObject() DO
		IF __QUERYINTERFACE(ParentStation.PathsBehinde.GetNextObject(), ipPath) THEN
			//get shortest distance
			fDistToParentStationStartup:= MIN(ipPath.DistanceToDestiantion(ipTrack:= THIS^.CurrentTrack, fPosOnTrack := THIS^.PositionOnTrack), fDistToParentStationStartup);
		END_IF
	END_WHILE
	ParentStation.PathsBehinde.RestoreIterator();	
	fDistToParentStationReturn := fDistToParentStationStartup;
// ---- ---- ----

// ---- Normal route dureing enabled system
ELSE
	THIS^.fbRouteComplete.ResetIterator();
	WHILE THIS^.fbRouteComplete.HasNextObject() DO
		IF __QUERYINTERFACE(THIS^.fbRouteComplete.GetNextObject(), ipPath) THEN
			fTotalLength := fTotalLength + ipPath.Length;
		
			IF NOT bPathFound THEN
				fTempDistToDest := ipPath.DistanceToDestiantion(ipTrack := THIS^.CurrentTrack, fPosOnTrack := THIS^.PositionOnTrack); 
				IF 	fTempDistToDest <> CHALET_BaseComponents.GVL_Datatypes.cMaxLreal THEN
					bPathFound := TRUE;
					fDistToParentStationReturn := fTempDistToDest;
				END_IF
			ELSE 
				fDistToParentStationReturn := fDistToParentStationReturn + ipPath.Length;
			END_IF
		END_IF
	END_WHILE
	THIS^.fbRouteComplete.RestoreIterator();
	// ---- ---- ----
	
	
	//--- If Mover is not on the path, return total length + dist to beginn
	IF NOT bPathFound THEN
		THIS^.fbRouteComplete.ResetIterator();
		IF __QUERYINTERFACE(THIS^.fbRouteComplete.GetNextObject(), ipPath) THEN
			refPosOnTrack REF= ipPath.StationDestination.PositionOnTrackXYZABC;
			fDistToBegin := F_DistXYVectors(THIS^.PositionAct, refPosOnTrack);	
		END_IF
		THIS^.fbRouteComplete.RestoreIterator();
		
		
		fDistToParentStationReturn := fDistToBegin + fTotalLength;
	END_IF
	 // ---- ---- ----

END_IF
// ---- ---- ----

DistToParentStation := fDistToParentStationReturn;

//Todo absturz, maximalwert von LREAL überschritten
//redce to 3 decimal places
//DistToParentStation := DINT_TO_LREAL(LREAL_TO_DINT(fDistToParentStationReturn*1000))/1000.0; 
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="DistToTrack" Id="{df1c51b6-4a3a-485b-b199-4d9e3147af19}" FolderPath="Track\">
      <Declaration><![CDATA[METHOD DistToTrack : LREAL
VAR_INPUT
	iTrack : I_XP_Track;
END_VAR
VAR
	fPositionOnTrack : LREAL;
	trackPosition, moverPosition : PositionXYC;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[moverPosition.x := PositionSet.x;
moverPosition.y := PositionSet.y;
moverPosition.c := PositionSet.c;

//Get Pos on track in mm
fPositionOnTrack := iTrack.PlanarTrack.GetArcLengthClosestTo(geometry:=moverPosition);

//Convert pos on track in XY
iTrack.PlanarTrack.GetPositionAt(arcLength := fPositionOnTrack, position:=trackPosition);

//Get distance to mover
DistToTrack := SQRT(EXPT((trackPosition.x - moverPosition.x),2)+EXPT((trackPosition.y - moverPosition.y),2));	
]]></ST>
      </Implementation>
    </Method>
    <Property Name="DynConstraint" Id="{697abf3e-8902-4714-b92e-712b3abb529c}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[PROPERTY DynConstraint : REFERENCE TO DynamicConstraint_Container]]></Declaration>
      <Get Name="Get" Id="{4d6e021c-1cf9-45fd-bcd1-89fc9b79e5ec}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[DynConstraint REF= THIS^.fbDynConstraintContainer;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Enable" Id="{6cc533e9-b130-4dda-9303-da74bf481acf}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Enable : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Enable;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;

	THIS^.fbMover.Enable(fbFeedbackEnable);
	Enable := S_OK;
ELSE
	Enable := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Property Name="Enabled" Id="{9dcc755c-22d8-4ebb-9deb-d00a82946100}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//operational and position control active(hovering)
PROPERTY Enabled : BOOL
]]></Declaration>
      <Get Name="Get" Id="{f4b6578f-34bc-45c9-a076-841689c10d04}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[(* StateDWord bit 20 - operational and position control active *)
Enabled :=  (THIS^.fbMover.MCTOPLC.STD.State = MC_PLANAR_STATE.Enabled) OR
			(THIS^.fbMover.MCTOPLC.STD.State = MC_PLANAR_STATE.Enabling) OR
			(THIS^.fbMover.MCTOPLC.STD.State = MC_PLANAR_STATE.Resetting AND PositionSet.z > 0.0) OR
			(THIS^.fbMover.MCTOPLC.STD.State = MC_PLANAR_STATE.Error AND PositionSet.z > 0.0) OR
			(THIS^.fbMover.MCTOPLC.STD.State = MC_PLANAR_STATE.ErrorPending AND PositionSet.z > 0.0) OR
			(THIS^.fbMover.MCTOPLC.STD.State = MC_PLANAR_STATE.Invalid AND PositionSet.z > 0.0);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{21a8add4-c8d4-4076-ab40-e5faffdc25ae}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	
	ipSystem : I_CH_Object;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Do the following code once during start up and not during onlinechange
IF NOT bInCopyCode THEN 
	
	
	(* Register to the Xplanar System
	   1. Test if the interface exists
	   2. Test if the object implements a "System for Mover" interface 
	*)
	IF ipSystem <> 0 AND_THEN __QUERYINTERFACE(ipSystem,THIS^.ipXpSystem) THEN
		THIS^.ipXpSystem.RegisterMover(THIS^);
	END_IF

	
	
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Feedback" Id="{5ec6e350-9706-452f-beac-38fa18f64b32}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Feedback : I_XP_Feedback]]></Declaration>
      <Get Name="Get" Id="{8883467e-e104-4f54-9601-4bfc49c0d708}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Feedback := THIS^.fbFeedback;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Halt" Id="{4d9969b0-eb07-4339-86a6-2d2b9d71a0ef}" FolderPath="Movement\">
      <Declaration><![CDATA[METHOD Halt : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Halt;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

THIS^.fbMover.Halt(	commandFeedback := THIS^.fbFeedbackHalt, 
					constraint 		:= THIS^.fbDynConstraintContainer 
				   );

Halt := S_OK;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Initialize" Id="{1afc7bf5-00ad-4187-ac31-771ca8ca47fe}">
      <Declaration><![CDATA[METHOD Initialize : HRESULT
VAR
	bWaitForAxisInit : BOOL;
	hrExtAxis : HRESULT;
	stVarInfo : __SYSTEM.VAR_INFO;
	
	nIdxXpu : UDINT;
	nIdxMover : UDINT;
	ipTcIoXpu : I_TcIoXPlanarProcessingUnit;	
	//nMoverOID : OTCID;
	nOidHardwareMover : OTCID;
	hr : HRESULT;
	ipComObject : ITComObject;
	nParaSize : UDINT;
	pParaData : PVOID;
END_VAR
VAR CONSTANT
	N_IDX_HARDWARE_MOVER_OID 	: UDINT := 16#0503012D; // Parameter(online) "Hardware mover OTCID"
END_VAR

VAR_INST
	//This error cannot be reset. Requires a reset cold
	{attribute 'hide'}	
	fbInitError : FB_TcAlarm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Check if link to MC-Mover is mapped
IF NOT THIS^.Mapped THEN
	IF NOT fbInitError.bRaised THEN 
		//This error cannot be reset. Requires a reset cold
		fbInitError.CreateEx(stEventEntry:=TC_EVENTS.CHALET_Base_Events.VariableLinkMissing, ipSourceInfo := THIS^.fbSourceInfo, bWithConfirmation := FALSE);
		stVarInfo := __VARINFO(fbMover);
		fbInitError.ipArguments.AddString(stVarInfo.Symbol);
		fbInitError.Raise(0);
	END_IF
	Initialize := E_FAIL;
	RETURN;
END_IF


	
IF NOT bInitDone THEN
	//Get MC-Mover interface to utiliy lib
	FOR nIdxMover := 1 TO ipXpSystem.Enviroment.UtilityEnvirement.P_MoverCount DO
		IF ipXpSystem.Enviroment.UtilityEnvirement.P_MoverOids[nIdxMover] = THIS^.fbMover.MCTOPLC.STD.MoverOID THEN
			THIS^.ipMcMover := ipXpSystem.Enviroment.UtilityEnvirement.McMover(nIdxMover);
			EXIT;
		END_IF
	END_FOR

	
	//get OID of to MC-Mover mapped TcIoMover
	hr := FW_ObjMgr_GetObjectInstance(oid:= THIS^.fbMover.MCTOPLC.STD.MoverOID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
	IF ipComObject <> 0 THEN
		//Get ADR and SIZE
		nParaSize := SIZEOF(nOidHardwareMover);	pParaData := ADR(nOidHardwareMover);
		hr := ipComObject.TcGetObjPara(pid:=N_IDX_HARDWARE_MOVER_OID , nData:= nParaSize, pData:= pParaData, pgp:=0 );
		FW_SafeRelease(ADR(ipComObject));
		
		IF nOidHardwareMover = 0 THEN
			//TODO Errormessage. MC is not mapped to TcIO
			RETURN;
		END_IF
	
		//Search interface for this OID
		FOR nIdxXpu := 1 TO ipXpSystem.Enviroment.UtilityEnvirement.P_XpuCount DO
			ipTcIoXpu := ipXpSystem.Enviroment.UtilityEnvirement.TcIoXpu(nIdxXpu);
			
			IF ipTcIoXpu <> 0 THEN
				//Get TcIo-Mover interface to utiliy lib
				FOR nIdxMover := 1 TO Param_TcIoXPlanarEnvironment.MaxXPlanarMoversPerXpu DO
					IF ipTcIoXpu.P_MoverOids[nIdxMover] = nOidHardwareMover THEN
						THIS^.ipTcIoMover := ipTcIoXpu.TcIoMover(nIdxMover);
						EXIT;
					END_IF
				END_FOR
			END_IF
		END_FOR	
	END_IF
	
	IF THIS^.ipTcIoMover = 0 OR THIS^.ipMcMover = 0 THEN
		//TODO Errormessage. Utility interface not found
		RETURN;
	END_IF
	

	//Set all move dynamic constraint to the axis default value.
	THIS^.SetDynConstraint_X(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);
	THIS^.SetDynConstraint_Y(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);	
	THIS^.SetDynConstraint_Z(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);	
	THIS^.SetDynConstraint_A(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);	
	THIS^.SetDynConstraint_B(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);
	THIS^.SetDynConstraint_C(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);
	THIS^.SetDynConstraint_Path(MC_DEFAULT,MC_DEFAULT,MC_DEFAULT,MC_DEFAULT);

	//Call Init of Setpointaxis only, if mapped
	IF AxisSetpointX.Mapped THEN hrExtAxis := GetMostSignificant(hrExtAxis, AxisSetpointX.Initialize());END_IF
	IF AxisSetpointY.Mapped THEN hrExtAxis := GetMostSignificant(hrExtAxis, AxisSetpointY.Initialize());END_IF
	IF AxisSetpointZ.Mapped THEN hrExtAxis := GetMostSignificant(hrExtAxis, AxisSetpointZ.Initialize());END_IF
	IF AxisSetpointA.Mapped THEN hrExtAxis := GetMostSignificant(hrExtAxis, AxisSetpointA.Initialize());END_IF
	IF AxisSetpointB.Mapped THEN hrExtAxis := GetMostSignificant(hrExtAxis, AxisSetpointB.Initialize());END_IF
	IF AxisSetpointC.Mapped THEN hrExtAxis := GetMostSignificant(hrExtAxis, AxisSetpointC.Initialize());END_IF	
	
	bInitDone := (hrExtAxis = S_OK);	
	
	
	//Pending
	Initialize := S_PENDING;;	
ELSE	
	//Done
	Initialize := S_OK;	
END_IF


THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Initialize;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;	
//Set done or keep in busy state	
THIS^.fbFeedback.HR := Initialize;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="JoinTrack" Id="{01c81af4-4f47-42d8-8d45-d28138d10e79}" FolderPath="Track\">
      <Declaration><![CDATA[METHOD JoinTrack : HRESULT
VAR_INPUT
	iTrack : I_XP_Track;
END_VAR
VAR
	joinTrackOptions : ST_JoinTrackOptions;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iTrack <> 0 THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.JoinTrack;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;

	
	(* ADS Error 33164 or 33154: Position out of modulo range or Software position limit violation. Position must be larger or equal to zero and less or equal to the modulus when using modulo positioning. 
		When using modulo positioning, the target position is interpreted in consideration of the AdditionalTurns variable at the Options input.

		If the above error occurs, then the mover wants to rotate on the track when joining because ‘useOrientation = TRUE’ is set. 
		Better do not to set this to false, because CA then requires a much greater distance to the neighbouring mover.
		It is better to check the set C-axis modules in the MC3 PlanarMover if 90, 180 or 360°.
	*)
	joinTrackOptions.useOrientation 	:= TRUE;

	
	THIS^.fbMover.JoinTrack(commandFeedback	:= THIS^.fbFeedbackJoinTrack, 
								targetTrack	:= iTrack.PlanarTrack, 
								constraint	:= THIS^.fbDynConstraintContainer,
								options		:= joinTrackOptions);								
	JoinTrack := S_OK;
ELSE
	JoinTrack := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="LagDistanceXY" Id="{fcf48610-378f-4081-835f-ac8255e20692}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Retruns lentgh of hypotenuse of the x and y error. (>=0[mm]) *)
PROPERTY LagDistanceXY : LREAL 
]]></Declaration>
      <Get Name="Get" Id="{e2520c51-1749-41b4-ae6b-97b024a8cfc5}">
        <Declaration><![CDATA[VAR
	fErrorX, fErrorY : LREAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[// Set - Act
fErrorX := THIS^.fbMover.MCTOPLC.SET.SetPos.X - THIS^.fbMover.MCTOPLC.ACT.ActPos.X;
fErrorY := THIS^.fbMover.MCTOPLC.SET.SetPos.Y - THIS^.fbMover.MCTOPLC.ACT.ActPos.Y;


//Dist to center. Phytagoras -> c = sqrt( A^2 + B^2)
LagDistanceXY := SQRT(EXPT(fErrorX,2) + EXPT(fErrorY,2));
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastCmdTargetGap" Id="{ca47efdf-1e96-4e64-b8e6-43f733c3da42}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//The last driving command given had the following value
PROPERTY LastCmdTargetGap : LREAL]]></Declaration>
      <Get Name="Get" Id="{fbbf4cb3-58d2-4862-af4b-6981a711799e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastCmdTargetGap := fLastCmdTargetGap;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastCmdTargetPosition" Id="{6482a76a-6491-4c21-89ec-7fa30453a7d3}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//The last driving command given had the following value
PROPERTY LastCmdTargetPosition : LREAL]]></Declaration>
      <Get Name="Get" Id="{8ec5f96b-7922-4cd0-b523-21fd282e52d5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastCmdTargetPosition := fLastCmdTargetPosition;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastCmdTargetTrack" Id="{4a89196f-6c6d-425e-991b-80e0f510161a}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//The last driving command given had the following value
PROPERTY LastCmdTargetTrack: I_XP_Track]]></Declaration>
      <Get Name="Get" Id="{474e9fbb-3f66-4e12-bb99-199d288e7964}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastCmdTargetTrack := ipLastCmdTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastValidParentStation" Id="{0159a9a4-bb4e-4a2b-8371-54291b9ebbf1}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//This was the last valid (system enabled) parent station of the mover
PROPERTY LastValidParentStation : I_XP_Station;]]></Declaration>
      <Get Name="Get" Id="{1e727396-87c4-4682-82b0-ffde063cd254}">
        <Declaration><![CDATA[VAR_INST

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastValidParentStation := THIS^.ipLastValidParentStation;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastValidPositionOnTrack" Id="{09f3cf5a-bd46-45b1-8866-6c162c445038}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//This was the last valid (system enabled) actual  position of the mover
PROPERTY LastValidPositionOnTrack : LREAL]]></Declaration>
      <Get Name="Get" Id="{6c8cd6d1-76b6-4eb9-80cb-3768d873a586}">
        <Declaration><![CDATA[VAR_INST

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastValidPositionOnTrack := THIS^.fLastValidPositionOnTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastValidPositionXYZABC" Id="{8a90fc36-48ce-41fc-a975-9837b9ce6e53}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//This was the last valid (system enabled) actual  position of the mover
PROPERTY LastValidPositionXYZABC : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{6bb82480-d451-4e15-b7e6-635ceb4efaf7}">
        <Declaration><![CDATA[VAR_INST

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastValidPositionXYZABC REF= THIS^.stLastValidPositionXYZABC;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="LastValidTrack" Id="{89eabedd-60aa-41d0-b809-07cf486e0552}" FolderPath="Recovery\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//This was the last valid (system enabled) actual  position of the mover
PROPERTY LastValidTrack : I_XP_Track;]]></Declaration>
      <Get Name="Get" Id="{5f3d9641-254e-45f4-9163-ed1b6bc8a7f7}">
        <Declaration><![CDATA[VAR_INST

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LastValidTrack := THIS^.ipLastValidTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="LiftFromUnknownLevel" Id="{74cea006-96ba-48bf-8d24-fd9b1707d0f0}" FolderPath="Lift/Lower\">
      <Declaration><![CDATA[//The mover returns to its SetPos. The force of the Z, A and B axis is slowly increased.
METHOD LiftFromUnknownLevel : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.LiftFromUnknownLevel;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);		
THIS^.fbFeedback.Busy 				:= TRUE;


IF THIS^.fbMover.MCTOPLC.STD.State <> MC_PLANAR_STATE.Enabled THEN
	//Error wrong state
	
	;//zzz Todo Error message
	
ELSIF NOT THIS^.Standstill THEN
	//Error not allowed if mover is moving
	
	;//zzz Todo Error message
	
ELSE
	//Start of internal sequence
	THIS^.fbFeedbackLiftFromUnknown.Busy		:= TRUE;
	THIS^.nSeqLiftFromUnknown := 1;
	THIS^.nSeqLowerToUnknown := 0;
END_IF



LiftFromUnknownLevel := S_OK;	

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="LowerToUnknownLevel" Id="{e789b74c-fe33-48b6-8b0b-5593dd96f5d7}" FolderPath="Lift/Lower\">
      <Declaration><![CDATA[(* The mover is lowered. The target height is unknown. The force from the Z, A and B axles is then reduced to a minimum. X, Y and C still remain active.
   This function can be used, for example, to place the mover in a holder.  *)
METHOD LowerToUnknownLevel : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.LowerToUnknownLevel;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);		
THIS^.fbFeedback.Busy 				:= TRUE;


IF THIS^.fbMover.MCTOPLC.STD.State <> MC_PLANAR_STATE.Enabled THEN
	//Error wrong state
	
	;//zzz Todo Error message

ELSIF NOT THIS^.Standstill THEN
	//Error not allowed if mover is moving
	
	;//zzz Todo Error message
	
	
ELSE
	//Start of internal sequence
	THIS^.fbFeedbackLowerToUnknown.Busy		:= TRUE;
	THIS^.nSeqLowerToUnknown := 1;
	THIS^.nSeqLiftFromUnknown := 0;
END_IF



LowerToUnknownLevel := S_OK;	

	]]></ST>
      </Implementation>
    </Method>
    <Property Name="Mapped" Id="{dcb60397-9711-4709-befc-4d0421e5330c}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Mapped : BOOL //Project is mapped to MC (McToPlc and PlcToMc)
]]></Declaration>
      <Get Name="Get" Id="{5ccf050e-f19f-4d36-8ab0-244c8a390056}">
        <Declaration><![CDATA[VAR
	bMcToPlcNotMapped 	: BOOL;
	bPlcToMcNotMapped 	: BOOL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//F_GetMappingStatus is not working on IO Data Pointer
	//bPlcToMcNotMapped := F_GetMappingStatus(ADR(THIS^.fbMover.PlcToMc), SIZEOF(THIS^.fbMover.PlcToMc)) <> EPlcMappingStatus.MS_Mapped;
	//bMcToPlcNotMapped := F_GetMappingStatus(ADR(THIS^.fbMover.McToPlc), SIZEOF(THIS^.fbMover.McToPlc)) <> EPlcMappingStatus.MS_Mapped;

	
Mapped := THIS^.fbMover.MCTOPLC.STD.MoverOID <> 0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Mode" Id="{caa3da53-3a25-4b03-9028-732dc39426fa}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Mode : MC_PLANAR_MOVER_COMMAND_MODE]]></Declaration>
      <Get Name="Get" Id="{bf2d901a-fe14-42df-b4ab-181d74468c10}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Mode := THIS^.fbMover.MCTOPLC.STD.CommandMode;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="MoveA" Id="{a5f4d8aa-5be8-48e7-b2a8-67dcf29ce4aa}" FolderPath="Movement\">
      <Declaration><![CDATA[METHOD MoveA : HRESULT
VAR_INPUT
	fPosition : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveA;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

THIS^.fbMover.MoveA(commandFeedback	:= THIS^.fbFeedbackMoveA, 
					targetPosition	:= fPosition, 
					constraint		:= THIS^.fbDynConstraintContainer
					);

MoveA := S_OK;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveB" Id="{bc2d3440-6541-47d1-a277-4ebeccb28445}" FolderPath="Movement\">
      <Declaration><![CDATA[METHOD MoveB : HRESULT
VAR_INPUT
	fPosition : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveB;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

THIS^.fbMover.MoveB(commandFeedback	:= THIS^.fbFeedbackMoveB, 
					targetPosition	:= fPosition, 
					constraint		:= THIS^.fbDynConstraintContainer
					);

MoveB := S_OK;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveC" Id="{16252da5-1d7c-45c2-87ec-a378debf7dca}" FolderPath="Movement\">
      <Declaration><![CDATA[METHOD MoveC : HRESULT
VAR_INPUT
	fPosition : LREAL;
	
	(* Addition turns to move in modulo movement (positive or negative). *)
	additionalTurns : UDINT := 0;
	
	(* Direction in which the target is approached. *)
	direction : Tc3_Mc3Definitions.MC_DIRECTION := Tc3_Mc3Definitions.MC_DIRECTION.mcDirectionNonModulo;
END_VAR
VAR
	stMoveCOptions : ST_MoveCOptions;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveC;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;


stMoveCOptions.additionalTurns := additionalTurns;
stMoveCOptions.direction := direction;


THIS^.fbMover.MoveC(commandFeedback	:= THIS^.fbFeedbackMoveC, 
					targetPosition	:= fPosition, 
					constraint		:= THIS^.fbDynConstraintContainer, 
					options			:= stMoveCOptions
					);

MoveC := S_OK;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveOnTrack" Id="{adfbf623-ad3d-4634-a0ef-a7968978cb31}" FolderPath="Track\">
      <Declaration><![CDATA[METHOD MoveOnTrack : HRESULT
VAR_INPUT
	ipTrack : I_XP_Track;
	fPosition : LREAL;
	fGap : LREAL;
END_VAR

VAR
	moveOptions: ST_MoveOnTrackOptions;
	//fMoverDiagonal : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[moveOptions.direction := Tc3_Mc3Definitions.MC_DIRECTION.mcDirectionPositive;
moveOptions.additionalTurns := 0;
moveOptions.gap := XPlanarParameterlist.N_GAP_MODE_ON_TRACK; 

//Use fix gap if requested gap is to small
moveOptions.gap := MAX(fGap, XPlanarParameterlist.F_MOVER_MINIMUM_GAP_ON_TRACK);
moveOptions.dynamicMode := XPlanarParameterlist.N_SELECT_MODE_HOW_DYNAMIC_IS_PLANED_ON_TRACK;

IF ipTrack <> 0 THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveOnTrack;
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;

	THIS^.fbMover.MoveOnTrack(
		commandFeedback			:= THIS^.fbFeedbackMoveOnTrack,
		targetTrack				:= ipTrack.PlanarTrack, 
		targetPositionOnTrack	:= fPosition, 
		constraint				:= THIS^.fbDynConstraintPath, 
		options					:= moveOptions);
	
	//Store the values
	fLastCmdTargetPosition 	:= fPosition; //the last commanded target position [mm]
	fLastCmdTargetGap 		:= moveOptions.gap; //the last commanded target gap
	ipLastCmdTrack		 	:= ipTrack; //the last commanded target track	
	
	
	MoveOnTrack := S_OK;
ELSE
	MoveOnTrack := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveOnTrack_ShortestWay" Id="{afa896ac-c697-48d6-a29f-92f3cf71b66b}" FolderPath="Track\">
      <Declaration><![CDATA[METHOD MoveOnTrack_ShortestWay : HRESULT
VAR_INPUT
	ipTrack : I_XP_Track;
	fPosition : LREAL;
	fGap : LREAL;
END_VAR

VAR
	moveOptions: ST_MoveOnTrackOptions;
	//fMoverDiagonal : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[moveOptions.direction := Tc3_Mc3Definitions.MC_DIRECTION.mcDirectionShortestWay;
moveOptions.additionalTurns := 0;
moveOptions.gap := XPlanarParameterlist.N_GAP_MODE_ON_TRACK; 

//Use fix gap if requested gap is to small
moveOptions.gap := MAX(fGap, XPlanarParameterlist.F_MOVER_MINIMUM_GAP_ON_TRACK);
moveOptions.dynamicMode := XPlanarParameterlist.N_SELECT_MODE_HOW_DYNAMIC_IS_PLANED_ON_TRACK;

IF ipTrack <> 0 THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveOnTrack;		
	THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;
	
	THIS^.fbMover.MoveOnTrack(
		commandFeedback			:= THIS^.fbFeedbackMoveOnTrack,
		targetTrack				:= ipTrack.PlanarTrack, 
		targetPositionOnTrack	:= fPosition, 
		constraint				:= THIS^.fbDynConstraintPath, 
		options					:= moveOptions);
				
	fLastCmdTargetPosition 	:= fPosition; //the last commanded target position [mm]
	fLastCmdTargetGap 		:= moveOptions.gap; //the last commanded target gap
	ipLastCmdTrack		 	:= ipTrack; //the last commanded target track	
		
	MoveOnTrack_ShortestWay := S_OK;
ELSE
	MoveOnTrack_ShortestWay := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveOnTrackToStation" Id="{d6eeb16a-1b2f-4acf-8273-82244551a1e3}" FolderPath="Track\">
      <Declaration><![CDATA[METHOD MoveOnTrackToStation : HRESULT
VAR_INPUT
	ipStation : I_XP_Station;
	fGap : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipStation <> 0 AND_THEN ipStation.AccocietedTrack <> 0 THEN

	MoveOnTrackToStation := MoveOnTrack(ipTrack:= ipStation.AccocietedTrack, 
										fPosition:= ipStation.PositionOnTrack, 
										fGap:= fGap);
ELSE
	MoveOnTrackToStation := E_FAIL;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="MoverHeight" Id="{4e60d99b-2818-4281-9e05-0f1610591b64}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Height that is used for internal collision checks.[mm] *)
PROPERTY MoverHeight : LREAL]]></Declaration>
      <Get Name="Get" Id="{2069dff8-b44f-4871-8302-36d11a5bde6a}">
        <Declaration><![CDATA[VAR
	ipTrackComObject : ITComObject;
	nParaSize : UDINT;
	pParaData : PVOID;
	hr : HRESULT;
	fData : LREAL;
END_VAR
VAR CONSTANT
	N_IDX_OFFSET 	: UDINT := 16#050300B3; // Parameter(init) Mover
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[FW_ObjMgr_GetObjectInstance(oid:= THIS^.OID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipTrackComObject));

IF ipTrackComObject = 0 THEN
	// Error
	RETURN;
END_IF


nParaSize := SIZEOF(fData);	pParaData := ADR(fData);

hr := ipTrackComObject.TcGetObjPara(pid:=N_IDX_OFFSET , nData:= nParaSize, pData:= pParaData, pgp:=0 );
FW_SafeRelease(ADR(ipTrackComObject));


MoverHeight := fData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="MoverIsNotPresent" Id="{436b50f4-7ab9-4b1a-975f-656b96205857}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Mover could not be detected or was removed from the system
PROPERTY MoverIsNotPresent : BOOL]]></Declaration>
      <Get Name="Get" Id="{e8e9327d-3d37-4e0b-a510-e8c07bff6a5d}">
        <Declaration><![CDATA[VAR
	bMoverAtZeroPos, bMoverPositionInvalid, bMoverVeloInvalid : BOOL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bMoverAtZeroPos		:=  PlanarMover.MCTOPLC.ACT.ActPos.x = 0 AND
						PlanarMover.MCTOPLC.ACT.ActPos.y = 0 AND 
						PlanarMover.MCTOPLC.ACT.ActPos.z = 0 AND 
						PlanarMover.MCTOPLC.ACT.ActPos.a = 0 AND
						PlanarMover.MCTOPLC.ACT.ActPos.b = 0 AND 
						PlanarMover.MCTOPLC.ACT.ActPos.c = 0 AND 
						PlanarMover.MCTOPLC.ACT.PhysicalAreaID = 0;
						
						
bMoverPositionInvalid:=  PlanarMover.MCTOPLC.ACT.ActPos.x >= 1E+302 AND
						PlanarMover.MCTOPLC.ACT.ActPos.y >= 1E+302 AND 
						PlanarMover.MCTOPLC.ACT.ActPos.z >= 1E+302 AND 
						PlanarMover.MCTOPLC.ACT.ActPos.a >= 1E+302 AND
						PlanarMover.MCTOPLC.ACT.ActPos.b >= 1E+302 AND 
						PlanarMover.MCTOPLC.ACT.ActPos.c >= 1E+302;
						
						
bMoverVeloInvalid	:=  PlanarMover.MCTOPLC.ACT.ActVelo.x >= 1E+302 AND
						PlanarMover.MCTOPLC.ACT.ActVelo.y >= 1E+302 AND 
						PlanarMover.MCTOPLC.ACT.ActVelo.z >= 1E+302 AND 
						PlanarMover.MCTOPLC.ACT.ActVelo.a >= 1E+302 AND
						PlanarMover.MCTOPLC.ACT.ActVelo.b >= 1E+302 AND 
						PlanarMover.MCTOPLC.ACT.ActVelo.c >= 1E+302;
						
MoverIsNotPresent := bMoverAtZeroPos OR bMoverPositionInvalid OR bMoverVeloInvalid;						
						
			]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="MoverWidth" Id="{2583efb8-5d9a-4053-952c-b913e0289c35}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Width that is used for internal collision checks.[mm] *)
PROPERTY MoverWidth : LREAL]]></Declaration>
      <Get Name="Get" Id="{7c7c28f5-6bff-4b33-8d6f-0224fc2e0d31}">
        <Declaration><![CDATA[VAR
	ipTrackComObject : ITComObject;
	nParaSize : UDINT;
	pParaData : PVOID;
	hr : HRESULT;
	fData : LREAL;
END_VAR
VAR CONSTANT
	N_IDX_OFFSET 	: UDINT := 16#050300B2; // Parameter(init) Mover
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[FW_ObjMgr_GetObjectInstance(oid:= THIS^.OID, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipTrackComObject));

IF ipTrackComObject = 0 THEN
	// Error
	RETURN;
END_IF


nParaSize := SIZEOF(fData);	pParaData := ADR(fData);
hr := ipTrackComObject.TcGetObjPara(pid:=N_IDX_OFFSET , nData:= nParaSize, pData:= pParaData, pgp:=0 );
FW_SafeRelease(ADR(ipTrackComObject));

MoverWidth := fData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="MoveXY" Id="{b4ad76d6-6055-4cdd-b12e-43b97b8b8ec6}" FolderPath="Movement\">
      <Declaration><![CDATA[METHOD MoveXY : HRESULT
VAR_INPUT
	fPosition_X : LREAL;
	fPosition_Y : LREAL;
END_VAR
VAR
	fbTargetPosition 	: PositionXYC;
	stMoveOptions 		: ST_MoveToPositionOptions;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveXY;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;



fbTargetPosition.SetValuesXY(x := fPosition_X, y := fPosition_Y);

stMoveOptions.useOrientation := TRUE;

THIS^.fbMover.MoveToPosition(	commandFeedback	:= THIS^.fbFeedbackMoveXY, 
								targetPosition	:= fbTargetPosition,
								constraint		:= THIS^.fbDynConstraintContainer, 
								options			:= stMoveOptions);

MoveXY := S_OK;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveZ" Id="{9f0e7f33-dcf7-4035-82ba-ccff9e3df6b3}" FolderPath="Movement\">
      <Declaration><![CDATA[METHOD MoveZ : HRESULT
VAR_INPUT
	fPosition : LREAL;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.MoveZ;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;


THIS^.fbMover.MoveZ(commandFeedback	:= THIS^.fbFeedbackMoveZ, 
					targetPosition	:= fPosition, 
					constraint		:= THIS^.fbDynConstraintContainer
					);

MoveZ := S_OK;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="OID" Id="{0abeb532-afdc-4dc2-9ab6-0807e7d91aa1}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Unique object ID
PROPERTY OID : OTCID ]]></Declaration>
      <Get Name="Get" Id="{599206fd-ce8e-4e24-8135-4fd698fd4855}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[OID := THIS^.fbMover.MCTOPLC.STD.MoverOID;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ParentStation" Id="{d9fe781b-0162-464e-80ee-068bdadaaf97}" FolderPath="Track\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY ParentStation : I_XP_Station
]]></Declaration>
      <Get Name="Get" Id="{11f40b20-0e02-418d-9959-a2eb7cec4d0d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ParentStation := ipParentStation;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{0ef48bce-75a9-45f9-a19f-0ecb454be508}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.ipParentStation := ParentStation;

IF ParentStation <> 0 THEN
	THIS^.ipLastValidParentStation := ParentStation;
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="PlanarMover" Id="{9ab2774b-0de5-4639-aebd-b4fa0b2af3a1}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PlanarMover : REFERENCE TO MC_PlanarMover]]></Declaration>
      <Get Name="Get" Id="{57faf404-2cc0-4ca0-a853-1d3ac688b597}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PlanarMover ref= THIS^.fbMover;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="PositionAct" Id="{384f3b6f-aeb2-44fd-ba87-4a2d1688cf55}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Contains the information of the Planar Mover passed from MC to PLC. XYZABC [mm] *)
PROPERTY PositionAct : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{c5fb2017-f63e-4e5e-bf3c-d6d5c0e1ae48}">
        <Declaration><![CDATA[VAR_INST
	{attribute 'hide'}
	copyOfActPosition :  MoverVector;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//Creat an copy of the struct to view value in targetdbrowser and plc online view
copyOfActPosition := THIS^.fbMover.MCTOPLC.ACT.ActPos;
PositionAct REF= copyOfActPosition;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="PositionOnTrack" Id="{4a0153f5-97b4-4376-baf2-04d64afb83b5}" FolderPath="Track\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PositionOnTrack : LREAL]]></Declaration>
      <Get Name="Get" Id="{06559a55-124b-46e7-b48f-ab959cd8f5a1}">
        <Declaration><![CDATA[VAR_INST
	{attribute 'hide'}	
	fPosOnTrack : LREAL;
END_VAR]]></Declaration>
        <Implementation>
          <ST><![CDATA[fPosOnTrack := THIS^.fbMover.MCTOPLC.SETONTRACK.SetPos;
PositionOnTrack := fPosOnTrack;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="PositionSet" Id="{ba1334d9-7a50-49e6-980d-a4811196b2e6}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Provides the current planar mover setpoint XYZABC [mm] *)
PROPERTY PositionSet : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{443bc0d2-54d2-481e-8023-c27bddd711ad}">
        <Declaration><![CDATA[VAR_INST
	{attribute 'hide'}
	copyOfSetPosition :  MoverVector;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//Creat an copy of the struct to view value in targetdbrowser and plc online view
copyOfSetPosition := THIS^.fbMover.MCTOPLC.SET.SetPos;
PositionSet REF= copyOfSetPosition;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Prepare" Id="{75ebe37d-1d93-4e15-83bc-21b836e7791f}">
      <Declaration><![CDATA[(* Time-critical information is processed here, which can then be polled via the property every cycle. 
The update method is usually at the end of the program and then it is already 'outdated'. *)
METHOD PRIVATE Prepare : HRESULT
VAR

END_VAR
VAR_INST
	{attribute 'hide'}
	nLastUpdatedCycleCount : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Check if this Cycle the dates are allready prepared
IF nLastUpdatedCycleCount <> TwinCAT_SystemInfoVarList._TaskInfo[THIS^.nTaskIndex].CycleCount THEN
	nLastUpdatedCycleCount := TwinCAT_SystemInfoVarList._TaskInfo[THIS^.nTaskIndex].CycleCount;

	//Stor last valide position im system is enabled
	IF ipXpSystem.Enabled THEN
		THIS^.stLastValidPositionXYZABC := THIS^.PositionSet;
		THIS^.fLastValidPositionOnTrack := THIS^.PositionOnTrack;
		THIS^.ipLastValidTrack := THIS^.CurrentTrack;
	END_IF

END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="ProductData" Id="{fca2bcf7-b4de-439b-aac0-63af2ca5a335}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC ProductData : I_XP_ProductData]]></Declaration>
      <Get Name="Get" Id="{f1a5a648-1e72-439f-867d-1fe8abbd1615}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ProductData := ipProductData;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{eddec3e2-9e9a-4c44-93fd-db88e177fd9c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[// No change. Same interface is set again
IF ipProductData = ProductData THEN
	;//Noting
	
ELSE

	// If allready an interface is linked. Unlink
	IF ipProductData <> 0 THEN
		ipProductData.LinkToMover(0);
		ipProductData := 0;
	END_IF
	
	// Link and store new interface
	IF ProductData <> 0 THEN
		ProductData.LinkToMover(THIS^);
		ipProductData := ProductData;
	END_IF
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="RemoveFromGroup" Id="{98f88a01-188a-4f7e-9d14-88c771b60702}" FolderPath="Group\">
      <Declaration><![CDATA[METHOD RemoveFromGroup : HRESULT

VAR
	iGroup: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.fbFeedback.Busy THEN
	THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.RemoveFromGroupe;
	THIS^.fbFeedback.ActiveCommand 	:= TO_STRING(THIS^.eActiveCommand);	
	THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
	THIS^.fbFeedback.Busy 				:= TRUE;
	
	THIS^.fbMover.RemoveFromGroup(THIS^.fbFeedbackRmvFromGrp);
	
	RemoveFromGroup := S_OK;
ELSE
	RemoveFromGroup := S_FALSE;
	THIS^.fbFeedback.LastCommandAccepted:= FALSE;	
END_IF






]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{c8def4ef-0dd7-4936-ac99-b601ff6334d8}" FolderPath="Enable/Disable\">
      <Declaration><![CDATA[METHOD Reset : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.Reset;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		
THIS^.fbFeedback.Busy 				:= TRUE;

THIS^.fbMover.Reset(THIS^.fbFeedbackReset);
Reset := S_OK;



]]></ST>
      </Implementation>
    </Method>
    <Property Name="RouteComplete" Id="{9447cb08-e1b2-48d7-ad55-d4e94022da5b}" FolderPath="RouteToParent\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Complete route from last parent to active parent station
PROPERTY RouteComplete : I_CH_List]]></Declaration>
      <Get Name="Get" Id="{a0c6e30e-1f5d-4f6a-b4dc-c70c0f990ace}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[RouteComplete := THIS^.fbRouteComplete;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="RouteRemaining" Id="{225c188a-e791-4700-b379-0e23d03c467b}" FolderPath="RouteToParent\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Remaining route to the parent
PROPERTY RouteRemaining: I_CH_List]]></Declaration>
      <Get Name="Get" Id="{6fce2f11-b3c5-45b0-b007-152ec2b18eb4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[RouteRemaining := THIS^.fbRouteRemaining;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="RouteSegmentDone" Id="{55e9e021-1da2-487c-876a-45bcc5abf875}" FolderPath="RouteToParent\">
      <Declaration><![CDATA[//done segments can be transferred here. these are removed from the remaining route
METHOD RouteSegmentDone : BOOL
VAR_INPUT
	ipPathDone : I_XP_Path;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RouteSegmentDone := THIS^.fbRouteRemaining.RemoveObject(ipPathDone);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_A" Id="{258e8b01-9716-4568-9659-e1dc2f970166}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_A : BOOL //Dynamic constraints for individual coordinates.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintCoordinates.SetLimit(	Coordinate := Coord_Mcs_A1, 
											V := V, 
											A := A, 
											D := D, 
											J := J);
											
//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_B" Id="{147c23e1-aaca-4dc9-8299-af07290b454e}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_B : BOOL //Dynamic constraints for individual coordinates.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintCoordinates.SetLimit(	Coordinate := Coord_Mcs_B1, 
											V := V, 
											A := A, 
											D := D, 
											J := J);											

//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_C" Id="{e293519e-04ca-495a-ae35-acc5845f3f05}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_C : BOOL //Dynamic constraints for individual coordinates.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintCoordinates.SetLimit(	Coordinate := Coord_Mcs_C1, 
											V := V, 
											A := A, 
											D := D, 
											J := J);											

//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_Path" Id="{2d8fba68-553d-426e-9766-a0ba4279103b}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_Path : BOOL //One dimensional dynamic constraint along the XY-components of a path, ignoring non-tangential effects.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintPath.SetValuesVADJ(V := V, 
										A := A, 
										D := D, 
										J := J);											

//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_X" Id="{427b41aa-b67d-4b25-99cf-dcd6b6e12269}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_X : BOOL //Dynamic constraints for individual coordinates.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintCoordinates.SetLimit(	Coordinate := Coord_Mcs_X, 
											V := V, 
											A := A, 
											D := D, 
											J := J);											

//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_Y" Id="{bd3c1d00-af64-45d0-a1d8-ae8483cb4e94}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_Y : BOOL //Dynamic constraints for individual coordinates.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintCoordinates.SetLimit(	Coordinate := Coord_Mcs_Y, 
											V := V, 
											A := A, 
											D := D, 
											J := J);											

//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDynConstraint_Z" Id="{0fe5ae40-476d-4ab9-ab87-925a572ad011}" FolderPath="DynamicConstraint\">
      <Declaration><![CDATA[METHOD SetDynConstraint_Z : BOOL //Dynamic constraints for individual coordinates.
VAR_INPUT
    V : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    A : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    D : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
    J : MC_LREAL; //equivalent to data type LREAL + MC_DEFAULT, MC_MAXIMUM
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbDynConstraintCoordinates.SetLimit(	Coordinate := Coord_Mcs_Z, 
											V := MC_DEFAULT, 
											A := A, 
											D := D, 
											J := J);											

//Changes to the origin constraint do not affect the copy of the constraint in the instance of the DynamicConstraint_Container.
//For this reason, the container is being refreshed here							
fbDynConstraintContainer.Clear();
fbDynConstraintContainer.AddConstraint(fbDynConstraintPath);
fbDynConstraintContainer.AddConstraint(fbDynConstraintCoordinates);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetRouteToParent" Id="{7ac32361-32cc-4ea7-a1f4-6c007f2bdb28}" FolderPath="RouteToParent\">
      <Declaration><![CDATA[METHOD SetRouteToParent : HRESULT
VAR_INPUT
	ipRoute : I_CH_LIST;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ipRoute = 0 THEN
	//Clear on empty input
	THIS^.fbRouteRemaining.Clear();
	THIS^.fbRouteComplete.Clear();
ELSE	
	//set as new route
	THIS^.fbRouteRemaining.Duplicate(ipRoute);
	THIS^.fbRouteComplete.Duplicate(ipRoute);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Standstill" Id="{0a4cd6a8-cc63-454a-b536-6c0ade3fd0bc}" FolderPath="Movement\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Velocity is zero *)
PROPERTY Standstill : BOOL]]></Declaration>
      <Get Name="Get" Id="{413d770e-3271-4399-b340-f1d8dfe909ac}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Standstill := TRUE;
Standstill := Standstill AND THIS^.PlanarMover.MCTOPLC.SET.SetVelo.x = 0;
Standstill := Standstill AND THIS^.PlanarMover.MCTOPLC.SET.SetVelo.y = 0;
Standstill := Standstill AND THIS^.PlanarMover.MCTOPLC.SET.SetVelo.z = 0;
Standstill := Standstill AND THIS^.PlanarMover.MCTOPLC.SET.SetVelo.a = 0;
Standstill := Standstill AND THIS^.PlanarMover.MCTOPLC.SET.SetVelo.b = 0;
Standstill := Standstill AND THIS^.PlanarMover.MCTOPLC.SET.SetVelo.c = 0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="StartExternalSetpoint" Id="{4f4a938c-622d-47f0-8bbe-7f1aa75cb8f5}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[METHOD StartExternalSetpoint : HRESULT
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.StartExternalSetpoint;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);		
THIS^.fbFeedback.Busy 				:= TRUE;


IF THIS^.fbMover.MCTOPLC.STD.State <> MC_PLANAR_STATE.Enabled THEN
	//Error wrong state
	
	;//zzz Todo Error message

ELSIF THIS^.bFeedExternalSetpointActive AND THIS^.nSeqStartExternalSetpoint = 999 THEN
	//Do nothing, setpoint is already active	
	THIS^.fbFeedbackExternalSetpointStartSeq.Done		:= TRUE;
	
ELSE
	
	//Start of internal sequence
	THIS^.fbFeedbackExternalSetpointStartSeq.Busy		:= TRUE;
	THIS^.nSeqStartExternalSetpoint := 1;
END_IF



StartExternalSetpoint := S_OK;	

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="StopExternalSetpoint" Id="{afa5ab34-a1f6-437c-aae3-df93db1b7b7f}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[METHOD StopExternalSetpoint : HRESULT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[AxisSetpointX.PowerOff();
AxisSetpointY.PowerOff();
AxisSetpointZ.PowerOff();
AxisSetpointA.PowerOff();
AxisSetpointB.PowerOff();
AxisSetpointC.PowerOff();


THIS^.eActiveCommand 				:= CHALET_NC.E_NcAxisCommands.StopExternalSetpoint;
THIS^.fbFeedback.ActiveCommand 		:= TO_STRING(THIS^.eActiveCommand);	
THIS^.fbFeedback.LastCommandAccepted:= TRUE;		


//Reset some flags
THIS^.nSeqStartExternalSetpoint := 0;
THIS^.bEvaluateFeedback := FALSE;
THIS^.ipMasterMover := 0;

IF THIS^.bFeedExternalSetpointActive THEN
	THIS^.fbMover.StopExternalSetpointGeneration(THIS^.fbFeedbackExtStop);	
	THIS^.bFeedExternalSetpointActive 	:= FALSE;
	THIS^.fbFeedback.Busy 				:= TRUE;
ELSE
	THIS^.fbFeedback.Done 				:= TRUE;
END_IF


StopExternalSetpoint := S_OK;]]></ST>
      </Implementation>
    </Method>
    <Property Name="System" Id="{2fb804d3-1a54-4817-84d1-21adb4af2ffc}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
//Interface to CHALET system to which this object belongs
PROPERTY System : I_XP_System_PLC]]></Declaration>
      <Get Name="Get" Id="{fa594037-9a16-4f1a-ab0a-e126ea4f39d7}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[//get I_x_System_PLC interface from I_x_System_Registration
__QUERYINTERFACE(THIS^.ipXpSystem, System);
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="TargetStation" Id="{126f0d16-a041-46ed-a396-2cbc60d632b5}" FolderPath="Track\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY TargetStation : STRING]]></Declaration>
      <Get Name="Get" Id="{f47b6c12-409e-4a37-bc20-97294fcfcafe}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TargetStation := THIS^.sTargetStation;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{e2830ca2-bb79-47b3-8db1-40364793a2cf}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.sTargetStation := TargetStation;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="Update" Id="{392ff8f6-dff3-42fc-aff2-06120a04576e}">
      <Declaration><![CDATA[METHOD PUBLIC Update : HRESULT
VAR
	ipObject : I_CH_Object;
END_VAR

VAR_INST
	{attribute 'hide'}
	fbCmdNotPossibleCollision : FB_TcAlarm;
	{attribute 'hide'}
	nFeedbackOidOld : UDINT;
	{attribute 'hide'}	
	nOldNcErrorCode 		: UDINT;
	{attribute 'hide'}	
	fbAlarmNcErrorCode		: FB_TcAlarm;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.Prepare();//Prepare time-critical information, if not already done

THIS^.UpdateExternalSetpoint();
THIS^.UpdateUnknownLevel();

// ********************** Set feedback depending on active command *******************************
CASE THIS^.eActiveCommand OF
	E_NcAxisCommands.None: 
		//Display if a Mover Error is active during no command is active
		IF THIS^.fbMover.Error AND NOT fbFeedback.Error THEN 
			IF THIS^.fbMover.ErrorId <> 1810(*ignore ADSERR_DEVICE_INVALIDSTATE*) THEN
				fbFeedback.ErrorId 			:= THIS^.fbMover.ErrorID;
				fbFeedback.ActiveCommand 	:= TO_STRING(E_NcAxisCommands.None);	
				fbFeedback.ClearObjectInfo();
			END_IF
		END_IF

	E_NcAxisCommands.Initialize:
		fbFeedback.Busy 			:= NOT THIS^.bInitDone;
		fbFeedback.Done 			:= THIS^.bInitDone;
		fbFeedback.ErrorId 			:= 0;
		fbFeedback.ClearObjectInfo();
		                        	
	E_NcAxisCommands.MoveA:     	
		fbFeedback.Busy 			:= fbFeedbackMoveA.Busy;
		fbFeedback.Done 			:= fbFeedbackMoveA.Done;
		fbFeedback.ErrorId 			:= fbFeedbackMoveA.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackMoveA.objectInfo;
                                	
	E_NcAxisCommands.MoveB:     	
		fbFeedback.Busy 			:= fbFeedbackMoveB.Busy;
		fbFeedback.Done 			:= fbFeedbackMoveB.Done;
		fbFeedback.ErrorId 			:= fbFeedbackMoveB.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackMoveB.objectInfo;
                                	
	E_NcAxisCommands.MoveC:     	
		fbFeedback.Busy 			:= fbFeedbackMoveC.Busy;
		fbFeedback.Done 			:= fbFeedbackMoveC.Done;
		fbFeedback.ErrorId 			:= fbFeedbackMoveC.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackMoveC.objectInfo;
                                	
	E_NcAxisCommands.MoveXY:    	
		fbFeedback.Busy 			:= fbFeedbackMoveXY.Busy;
		fbFeedback.Done 			:= fbFeedbackMoveXY.Done;
		fbFeedback.ErrorId 			:= fbFeedbackMoveXY.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackMoveXY.objectInfo;
                                	
	E_NcAxisCommands.MoveZ:     	
		fbFeedback.Busy 			:= fbFeedbackMoveZ.Busy;
		fbFeedback.Done 			:= fbFeedbackMoveZ.Done;
		fbFeedback.ErrorId 			:= fbFeedbackMoveZ.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackMoveZ.objectInfo;
                                	
	E_NcAxisCommands.Enable:    	
		fbFeedback.Busy 			:= fbFeedbackEnable.Busy;
		fbFeedback.Done 			:= fbFeedbackEnable.Done;
		fbFeedback.ErrorId 			:= fbFeedbackEnable.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackEnable.objectInfo;
                                	
	E_NcAxisCommands.Disable:   	
		fbFeedback.Busy 			:= fbFeedbackDisable.Busy;
		fbFeedback.Done 			:= fbFeedbackDisable.Done;
		fbFeedback.ErrorId 			:= fbFeedbackDisable.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackDisable.objectInfo;
                                	
	E_NcAxisCommands.Reset:     	
		fbFeedback.Busy 			:= fbFeedbackReset.Busy;
		fbFeedback.Done 			:= fbFeedbackReset.Done;
		fbFeedback.ErrorId 			:= fbFeedbackReset.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackReset.objectInfo;
                                	
	E_NcAxisCommands.Halt:      	
		fbFeedback.Busy 			:= fbFeedbackHalt.Busy;
		fbFeedback.Done 			:= fbFeedbackHalt.Done;
		fbFeedback.ErrorId 			:= fbFeedbackHalt.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackHalt.objectInfo;

	E_NcAxisCommands.AddToGroupe:
		fbFeedback.Busy 			:= fbFeedbackAddToGrp.Busy;
		fbFeedback.Done 			:= fbFeedbackAddToGrp.Done;
		fbFeedback.ErrorId 			:= fbFeedbackAddToGrp.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackAddToGrp.objectInfo;

	E_NcAxisCommands.RemoveFromGroupe:
		fbFeedback.Busy 			:= fbFeedbackRmvFromGrp.Busy;
		fbFeedback.Done 			:= fbFeedbackRmvFromGrp.Done;
		fbFeedback.ErrorId 			:= fbFeedbackRmvFromGrp.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackRmvFromGrp.objectInfo;
		
	E_NcAxisCommands.JoinTrack:
		fbFeedback.Busy 			:= fbFeedbackJoinTrack.Busy;
		fbFeedback.Done 			:= fbFeedbackJoinTrack.Done;
		fbFeedback.ErrorId 			:= fbFeedbackJoinTrack.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackJoinTrack.objectInfo;
		
	E_NcAxisCommands.MoveOnTrack:
		fbFeedback.Busy 			:= fbFeedbackMoveOnTrack.Busy;
		fbFeedback.Done 			:= fbFeedbackMoveOnTrack.Done;
		fbFeedback.ErrorId 			:= fbFeedbackMoveOnTrack.ErrorID;
        fbFeedback.ObjectInfo		:= fbFeedbackMoveOnTrack.objectInfo;
		
			
	E_NcAxisCommands.StartExternalSetpoint:
		;// in Subroutine "UpdateExternalSetpoint"
	
	E_NcAxisCommands.StopExternalSetpoint:
		;// in Subroutine "UpdateExternalSetpoint"		
			
	E_NcAxisCommands.LiftFromUnknownLevel:
		fbFeedback.Busy 			:= fbFeedbackLiftFromUnknown.Busy;
		fbFeedback.Done 			:= fbFeedbackLiftFromUnknown.Done;
		fbFeedback.ErrorId 			:= fbFeedbackLiftFromUnknown.ErrorID;
        fbFeedback.ClearObjectInfo();
	
	E_NcAxisCommands.LowerToUnknownLevel:
		fbFeedback.Busy 			:= fbFeedbackLowerToUnknown.Busy;
		fbFeedback.Done 			:= fbFeedbackLowerToUnknown.Done;
		fbFeedback.ErrorId 			:= fbFeedbackLowerToUnknown.ErrorID;
        fbFeedback.ClearObjectInfo();
		
	ELSE//External command in subclass
		;
END_CASE


// **********************  Stop to execute commands on .done or .error ***************************
IF fbFeedback.Done OR THIS^.fbFeedback.Error THEN
	eActiveCommand 				:= E_NcAxisCommands.None;
END_IF


// **********************  Get interface to Feedback.ObjectInfo ***************************
IF Feedback.ObjectInfoEx.Id <> 0 AND Feedback.ObjectInfoEx.Id <> nFeedbackOidOld THEN
	CASE Feedback.ObjectInfo.ObjectType OF
		EPlanarObjectType.Mover:
			Feedback.ObjectInfoEx.ipObject := THIS^.ipXPSystem.MoversPresent.FindOID(Feedback.ObjectInfo.Id);
			
		EPlanarObjectType.Track:
				Feedback.ObjectInfoEx.ipObject := THIS^.ipXPSystem.Tracks.FindOID(Feedback.ObjectInfo.Id);
		
		EPlanarObjectType.Environment:
				Feedback.ObjectInfoEx.ipObject := THIS^.ipXPSystem.Enviroment;
				
		ELSE 
			Feedback.ObjectInfoEx.ipObject := 0;
	END_CASE
END_IF
nFeedbackOidOld := Feedback.ObjectInfo.Id;



// **********************  Write NC-Error(Mover.MCTOPLC.ErrorCode) in TC3 Eventlogger ***************************
IF (THIS^.fbMover.MCTOPLC.STD.ErrorCode = 0 AND fbAlarmNcErrorCode.bRaised) THEN
	//No error - Reset	
	fbAlarmNcErrorCode.Clear(0,0);
	
ELSIF (THIS^.fbMover.MCTOPLC.STD.ErrorCode = 0) THEN
	; //Nothing
	
ELSIF (nOldNcErrorCode <> THIS^.fbMover.MCTOPLC.STD.ErrorCode) THEN
	//New Error - Reset, Create and Raise
	fbAlarmNcErrorCode.Clear(0,0);
	fbAlarmNcErrorCode.Create(	eventClass		:= TC_EVENT_CLASSES.Tc3_NcErrorCodes, 
								nEventId		:= (TO_DWORD(THIS^.fbMover.MCTOPLC.STD.ErrorCode) AND 16#FFFF), //Cut HRESULT to 4 digit error code
								eSeverity		:= TcEventSeverity.Error, 
								ipSourceInfo 	:= THIS^.fbSourceInfo, 
								bWithConfirmation := FALSE);
	fbAlarmNcErrorCode.ipArguments.Clear();
	fbAlarmNcErrorCode.Raise(0);
ELSE
	//Alarm is already active
	;
END_IF
nOldNcErrorCode := THIS^.fbMover.MCTOPLC.STD.ErrorCode;



// **********************  Raise alarm on collision error ***************************
ipObject := THIS^.fbFeedback.ObjectInfoEx.ipObject;
IF THIS^.fbFeedback.Error AND (ipObject <> 0) AND NOT fbCmdNotPossibleCollision.bRaised THEN
	fbCmdNotPossibleCollision.CreateEx(stEventEntry := TC_EVENTS.CHALET_XPlanar_Events.CommandNotPossibleCollision, bWithConfirmation := FALSE, ipSourceInfo := THIS^.fbSourceInfo);
	//Command "{1}" not possible. Possible collision with "{2}"
	fbCmdNotPossibleCollision.ipArguments.AddStringByValue(THIS^.fbFeedback.ActiveCommand).AddStringByValue(ipObject.LUID);
	fbCmdNotPossibleCollision.Raise(0);
ELSIF NOT THIS^.fbFeedback.Error OR ipObject = 0 THEN
	fbCmdNotPossibleCollision.Clear(0,0);	
END_IF




//Update xplanar object
THIS^.fbMover.Update();



//Update feedback object
fbFeedbackMoveA.Update(); 
fbFeedbackMoveB.Update(); 
fbFeedbackMoveC.Update(); 
fbFeedbackMoveXY.Update(); 
fbFeedbackMoveZ.Update(); 
fbFeedbackEnable.Update(); 
fbFeedbackDisable.Update(); 
fbFeedbackReset.Update(); 
fbFeedbackAddToGrp.Update(); 
fbFeedbackRmvFromGrp.Update(); 
fbFeedbackHalt.Update(); 
fbFeedbackJoinTrack.Update(); 
fbFeedbackMoveOnTrack.Update();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateExternalSetpoint" Id="{d324887b-a4fd-42e1-ab24-f67baaf90acf}" FolderPath="ExternalSetpoint\">
      <Declaration><![CDATA[METHOD PROTECTED UpdateExternalSetpoint : HRESULT
VAR
	SetPos, SetVelo, SetAcc : MoverVector;
	hr : HRESULT;
	stStartOptions : ST_ExternalSetpointGenerationOptions;
	stPosDifferenceToMasterMover : MoverVector;
	stPosOffsetMasterMover : MoverVector;
	stVeloOffsetMasterMover : MoverVector;
	stAccOffsetMasterMover : MoverVector;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.Enabled THEN
	THIS^.nSeqStartExternalSetpoint := 0;
	THIS^.bFeedExternalSetpointActive := FALSE;
	THIS^.bEvaluateFeedback := FALSE;
END_IF


CASE nSeqStartExternalSetpoint OF
	0: //Wait for start
		;
		
	1: 	//store position of Master-Mover
		IF (THIS^.ipMasterMover <> 0) THEN
			THIS^.stMasterPositionAtStart := THIS^.ipMasterMover.PositionSet;
		END_IF

		//Reset all axis
		IF AxisSetpointX.Mapped THEN
			AxisSetpointX.Reset();
		END_IF
		IF AxisSetpointY.Mapped THEN
			AxisSetpointY.Reset();
		END_IF
		IF AxisSetpointZ.Mapped THEN
			AxisSetpointZ.Reset();
		END_IF
		IF AxisSetpointA.Mapped THEN
			AxisSetpointA.Reset();
		END_IF
		IF AxisSetpointB.Mapped THEN
			AxisSetpointB.Reset();
		END_IF
		IF AxisSetpointC.Mapped THEN
			AxisSetpointC.Reset();
		END_IF
		nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;		
		
		
	2: //Wait for feedback
		IF AxisSetpointX.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointX.Feedback.HR); END_IF
		IF AxisSetpointY.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointY.Feedback.HR); END_IF
		IF AxisSetpointZ.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointZ.Feedback.HR); END_IF
		IF AxisSetpointA.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointA.Feedback.HR); END_IF
		IF AxisSetpointB.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointB.Feedback.HR); END_IF
		IF AxisSetpointC.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointC.Feedback.HR); END_IF	
		IF hr = S_OK THEN
		 	nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;	
		END_IF
		
	3: 	//Reset all axis
		IF AxisSetpointX.Mapped THEN
			AxisSetpointX.PowerOn();
		END_IF
		IF AxisSetpointY.Mapped THEN
			AxisSetpointY.PowerOn();
		END_IF
		IF AxisSetpointZ.Mapped THEN
			AxisSetpointZ.PowerOn();
		END_IF
		IF AxisSetpointA.Mapped THEN
			AxisSetpointA.PowerOn();
		END_IF
		IF AxisSetpointB.Mapped THEN
			AxisSetpointB.PowerOn();
		END_IF
		IF AxisSetpointC.Mapped THEN
			AxisSetpointC.PowerOn();
		END_IF
		nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;		
		
	4: //Wait for feedback
		IF AxisSetpointX.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointX.Feedback.HR); END_IF
		IF AxisSetpointY.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointY.Feedback.HR); END_IF
		IF AxisSetpointZ.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointZ.Feedback.HR); END_IF
		IF AxisSetpointA.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointA.Feedback.HR); END_IF
		IF AxisSetpointB.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointB.Feedback.HR); END_IF
		IF AxisSetpointC.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointC.Feedback.HR); END_IF	
		IF hr = S_OK THEN
		 	nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;	
		END_IF

	5: 	//Enable all axis
		IF AxisSetpointX.Mapped THEN
			AxisSetpointX.SetActPosition(0.0);
		END_IF
		IF AxisSetpointY.Mapped THEN
			AxisSetpointY.SetActPosition(0.0);
		END_IF
		IF AxisSetpointZ.Mapped THEN
			AxisSetpointZ.SetActPosition(0.0);
		END_IF
		IF AxisSetpointA.Mapped THEN
			AxisSetpointA.SetActPosition(0.0);
		END_IF
		IF AxisSetpointB.Mapped THEN
			AxisSetpointB.SetActPosition(0.0);
		END_IF
		IF AxisSetpointC.Mapped THEN
			AxisSetpointC.SetActPosition(0.0);
		END_IF
		nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;		
		
	6: //Wait for feedback
		IF AxisSetpointX.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointX.Feedback.HR); END_IF
		IF AxisSetpointY.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointY.Feedback.HR); END_IF
		IF AxisSetpointZ.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointZ.Feedback.HR); END_IF
		IF AxisSetpointA.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointA.Feedback.HR); END_IF
		IF AxisSetpointB.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointB.Feedback.HR); END_IF
		IF AxisSetpointC.Mapped THEN hr := GetMostSignificant(hr, AxisSetpointC.Feedback.HR); END_IF	
		IF hr = S_OK THEN
		 	nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;	
		END_IF

		
	7: // Activate external setpoint mode on mover
		stStartOptions.Mode := MC_EXTERNAL_SET_POSITION_MODE.Relative;
		THIS^.fbMover.StartExternalSetpointGeneration(	commandFeedback	:= THIS^.fbFeedbackExtStart,
														options 		:= stStartOptions);
		THIS^.bFeedExternalSetpointActive := TRUE;												
		nSeqStartExternalSetpoint := nSeqStartExternalSetpoint + 1;
	
		
	8: 
		THIS^.bEvaluateFeedback := TRUE;
		IF THIS^.fbFeedbackExtStart.Done THEN
			//Finish Sequence
			fbFeedbackExternalSetpointStartSeq.Done := TRUE;
			nSeqStartExternalSetpoint := 999;
		END_IF
		
	999: // finish seqence feedback
		
		
	1000..1999:
		//Error
		fbFeedbackExternalSetpointStartSeq.HR := E_FAIL;
END_CASE



IF THIS^.bFeedExternalSetpointActive THEN
	SetPos.X := AxisSetpointX.SetPosition;
	SetPos.Y := AxisSetpointY.SetPosition;
	SetPos.Z := AxisSetpointZ.SetPosition;
	SetPos.A := AxisSetpointA.SetPosition;
	SetPos.B := AxisSetpointB.SetPosition;
	SetPos.C := AxisSetpointC.SetPosition;
	
	SetVelo.X := AxisSetpointX.SetVelocity;
	SetVelo.Y := AxisSetpointY.SetVelocity;
	SetVelo.Z := AxisSetpointZ.SetVelocity;
	SetVelo.A := AxisSetpointA.SetVelocity;
	SetVelo.B := AxisSetpointB.SetVelocity;
	SetVelo.C := AxisSetpointC.SetVelocity;
	
	SetAcc.X := AxisSetpointX.SetAcceleration;
	SetAcc.Y := AxisSetpointY.SetAcceleration;
	SetAcc.Z := AxisSetpointZ.SetAcceleration;
	SetAcc.A := AxisSetpointA.SetAcceleration;
	SetAcc.B := AxisSetpointB.SetAcceleration;
	SetAcc.C := AxisSetpointC.SetAcceleration;
	
	IF THIS^.ipMasterMover <> 0 THEN
		//Difference to gearIn position
		stPosDifferenceToMasterMover := F_Vector_Subtraction(	minuend := THIS^.ipMasterMover.PositionSet, 
																subtrahend := stMasterPositionAtStart);
		//Add scaling factor	
		stPosOffsetMasterMover := F_Vector_Multiplication(	factor1 := stPosDifferenceToMasterMover,
															factor2 := THIS^.stMasterMovementScaling);							
		stVeloOffsetMasterMover := F_Vector_Multiplication(	factor1 := THIS^.ipMasterMover.VelocitySet,
															factor2 := THIS^.stMasterMovementScaling);							
		stAccOffsetMasterMover := F_Vector_Multiplication(	factor1 := THIS^.ipMasterMover.AccelerationSet,
															factor2 := THIS^.stMasterMovementScaling);						
		
		
		//Add Mastermover-Offest to 6-Axis-Offset
		SetPos := F_Vector_Addition( 	summand1 := stPosOffsetMasterMover,
									 	summand2 := SetPos);
		SetVelo := F_Vector_Addition( 	summand1 := stVeloOffsetMasterMover,
									 	summand2 := SetVelo);
		SetAcc := F_Vector_Addition( 	summand1 := stAccOffsetMasterMover,
									 	summand2 := SetAcc);
														
	END_IF
	
	//Send data to mover
	THIS^.fbMover.SetExternalSetpoint(	setPosition 		:= SetPos, 
										setVelocity 		:= SetVelo,
										setAcceleration 	:= SetAcc);
END_IF



CASE THIS^.eActiveCommand OF
	//Add the 6 axis to the feedback			
	E_NcAxisCommands.StartExternalSetpoint:
		//Only check MC_PlanarFeedback if cmd is active. Ignore old feedback
		IF THIS^.bEvaluateFeedback THEN
			fbFeedback.Busy 		:= fbFeedbackExtStart.Busy;
			fbFeedback.Done 		:= fbFeedbackExtStart.Done;
			fbFeedback.ErrorId 		:= fbFeedbackExtStart.ErrorID;
			fbFeedback.ClearObjectInfo();
		END_IF
		fbFeedback.HR := GetMostSignificant(fbFeedback.HR, fbFeedbackExternalSetpointStartSeq.HR);
		IF AxisSetpointX.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointX.Feedback.HR);END_IF
		IF AxisSetpointY.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointY.Feedback.HR);END_IF
		IF AxisSetpointZ.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointZ.Feedback.HR);END_IF
		IF AxisSetpointA.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointA.Feedback.HR);END_IF
		IF AxisSetpointB.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointB.Feedback.HR);END_IF
		IF AxisSetpointC.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointC.Feedback.HR);END_IF
		
	//Add the 6 axis to the feedback	
	E_NcAxisCommands.StopExternalSetpoint:
		fbFeedback.Busy 		:= fbFeedbackExtStop.Busy;
		fbFeedback.Done 		:= fbFeedbackExtStop.Done;
		fbFeedback.ErrorId 		:= fbFeedbackExtStop.ErrorID;
		fbFeedback.ClearObjectInfo(); 
		IF AxisSetpointX.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointX.Feedback.HR);END_IF
		IF AxisSetpointY.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointY.Feedback.HR);END_IF
		IF AxisSetpointZ.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointZ.Feedback.HR);END_IF
		IF AxisSetpointA.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointA.Feedback.HR);END_IF
		IF AxisSetpointB.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointB.Feedback.HR);END_IF
		IF AxisSetpointC.Mapped THEN fbFeedback.HR := GetMostSignificant(fbFeedback.HR, AxisSetpointC.Feedback.HR);END_IF
END_CASE		


fbFeedbackExtStart.Update(); 
fbFeedbackExtStop.Update(); 


IF AxisSetpointX.Mapped THEN AxisSetpointX.Update() ;END_IF
IF AxisSetpointY.Mapped THEN AxisSetpointY.Update() ;END_IF
IF AxisSetpointZ.Mapped THEN AxisSetpointZ.Update() ;END_IF
IF AxisSetpointA.Mapped THEN AxisSetpointA.Update() ;END_IF
IF AxisSetpointB.Mapped THEN AxisSetpointB.Update() ;END_IF
IF AxisSetpointC.Mapped THEN AxisSetpointC.Update() ;END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateUnknownLevel" Id="{cd7c4d75-1bdc-403d-95c4-20dc11727512}" FolderPath="Lift/Lower\">
      <Declaration><![CDATA[METHOD PROTECTED UpdateUnknownLevel : HRESULT
VAR
	hr : HRESULT;
	stForceLimitMax: Tc3_XPlanarUtility.Force6D;
	stForceLimitMin: Tc3_XPlanarUtility.Force6D;
	stPosLagValueTemp : MoverVector;
	ipComObject: Tc3_Module.ITComObject;
	pstForcesAtBeginn : POINTER TO MoverVector;
END_VAR
VAR_INST
	fLowerNPerS : LREAL := 30.0;
	fLiftNPerS : LREAL := 50.0;
	fMaxForceFactor : LREAL := 1.0;
	fMinForceFactor : LREAL := 0.1;
	fPowerFactor : LREAL := 1.0;
	fCycleTime_s : LREAL; //[s]	
	bDoOnceIfDisabled : BOOL;
	stLagValuesAtBeginn : MoverVector;
	stForcesAtBeginn :  MoverVector;
	stForceLimitMaxAtBeginn : Tc3_XPlanarUtility.Force6D;
	stForceLimitMinAtBeginn : Tc3_XPlanarUtility.Force6D;
	stValideMinForce		: Tc3_XPlanarUtility.Force6D;
END_VAR
VAR CONSTANT
	N_PTCID_ForceLimitMax : PTCID := 16#03175051;
	N_PTCID_ForceLimitMin : PTCID := 16#03175052;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.Enabled THEN
	THIS^.nSeqLowerToUnknown := 0;
	THIS^.nSeqLiftFromUnknown := 0;
	
	fCycleTime_s :=  TO_LREAL(TwinCAT_SystemInfoVarList._TaskInfo[THIS^.nTaskIndex].CycleTime(*100ns*)) / 10_000_000.0;
	stLagValuesAtBeginn := THIS^.UtilityMcMover.GetMaximumPositionLagValue();
END_IF

//if no TcIoMover is linked e.g. MC-Mover is in Simulation Mover:
IF THIS^.UtilityTcIoMover = 0 THEN
	IF fbFeedbackLowerToUnknown.Busy THEN
		fbFeedbackLowerToUnknown.Done := TRUE;
	END_IF
	IF fbFeedbackLiftFromUnknown.Busy THEN
		fbFeedbackLiftFromUnknown.Done := TRUE;
	END_IF
	RETURN;
END_IF



IF THIS^.ipXpSystem.Disabled AND bDoOnceIfDisabled THEN
	bDoOnceIfDisabled := FALSE;
	fPowerFactor := fMaxForceFactor;
	
	FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
	IF ipComObject <> 0 THEN
		// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
		// The minimum is therefore first written to something valid. Followed by Max and the original minimum
		hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
		hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMaxAtBeginn), pData := ADR(stForceLimitMaxAtBeginn), pgp := 0);
		hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMinAtBeginn), pData := ADR(stForceLimitMinAtBeginn), pgp := 0);
		FW_SafeRelease(ADR(ipComObject));
	END_IF

	THIS^.UtilityMcMover.SetMaximumPositionLagValue(stLagValuesAtBeginn);
END_IF


//Down
CASE nSeqLowerToUnknown OF
	0: //Wait for start
		;
		
	1: // Check if not already lewered	
		IF fPowerFactor = fMinForceFactor THEN
			nSeqLowerToUnknown := 999;
		ELSE
			nSeqLowerToUnknown := 5;
		END_IF
		
	5:	//Get some values
		pstForcesAtBeginn := THIS^.UtilityTcIoMover.ScopeAdr.GetOutputForce();
		stForcesAtBeginn := pstForcesAtBeginn^;
		stForceLimitMaxAtBeginn := THIS^.UtilityTcIoMover.GetForceLimitMax();
		stForceLimitMinAtBeginn := THIS^.UtilityTcIoMover.GetForceLimitMin();
		stValideMinForce.Fx := (stForceLimitMinAtBeginn.Fx * fMinForceFactor);
		stValideMinForce.Fy := (stForceLimitMinAtBeginn.Fy * fMinForceFactor);
		stValideMinForce.Fz := (stForceLimitMinAtBeginn.Fz * fMinForceFactor);
		stValideMinForce.Mx := (stForceLimitMinAtBeginn.Mx * fMinForceFactor);
		stValideMinForce.My := (stForceLimitMinAtBeginn.My * fMinForceFactor);
		stValideMinForce.Mz := (stForceLimitMinAtBeginn.Mz * fMinForceFactor);
		bDoOnceIfDisabled := TRUE;
		
		stPosLagValueTemp := stLagValuesAtBeginn;
		stPosLagValueTemp.z := THIS^.PositionSet.z + 0.5;
		THIS^.UtilityMcMover.SetMaximumPositionLagValue(stPosLagValueTemp);
		
		
		//0.0 - 1.0
		fPowerFactor := (stForcesAtBeginn.z / stForceLimitMaxAtBeginn.Fz);
		
		//add 5%
		fPowerFactor := fPowerFactor + 0.05;
		
		//Limit to 0.1 - 1.0
		fPowerFactor := MIN(fPowerFactor, fMaxForceFactor);
		fPowerFactor := MAX(fPowerFactor, fMinForceFactor);
		
		//set force Z, a and b
		stForceLimitMin := stForceLimitMinAtBeginn;		
		stForceLimitMin.fz := stForceLimitMin.Fz * fPowerFactor;
		stForceLimitMin.Mx := stForceLimitMin.Mx * fPowerFactor;
		stForceLimitMin.My := stForceLimitMin.My * fPowerFactor;
		
		stForceLimitMax := stForceLimitMaxAtBeginn;	
		stForceLimitMax.fz := stForceLimitMax.Fz * fPowerFactor;
		stForceLimitMax.Mx := stForceLimitMax.Mx * fPowerFactor;
		stForceLimitMax.My := stForceLimitMax.My * fPowerFactor;

		// 13.01.2025 Todo PLC Chash if Min > Max. use objParm insted
		//	THIS^.TcIoXPlanarMover.SetForceLimitMin(stForceLimitMin);
		//	THIS^.TcIoXPlanarMover.SetForceLimitMax(stForceLimitMax);
		FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
		IF ipComObject <> 0 THEN	
			// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
			// The minimum is therefore first written to something valid. Followed by Max and the original minimum
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMax), pData := ADR(stForceLimitMax), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMin), pData := ADR(stForceLimitMin), pgp := 0);
			FW_SafeRelease(ADR(ipComObject));
		END_IF

	
		nSeqLowerToUnknown := 10;
		
		
	10: 	
		//A lowering of the mover was detected followed by speed ~0
		IF (THIS^.PositionAct.z < THIS^.PositionSet.z * 0.5) AND (ABS(THIS^.VelocityAct.z) < 5.0)  THEN
			nSeqLowerToUnknown := 20;
			
		ELSIF (fPowerFactor <= fMinForceFactor) THEN
			nSeqLowerToUnknown := 20;
				
		ELSE
			//Reduce force each cycle
			fPowerFactor := fPowerFactor - ((fLowerNPerS/stForceLimitMaxAtBeginn.Fz) * fCycleTime_s);
					
			//Limit to 0.1 - 1.0
			fPowerFactor := MIN(fPowerFactor, fMaxForceFactor);
			fPowerFactor := MAX(fPowerFactor, fMinForceFactor);
			
			//set force Z, a and b to current + 10%
			stForceLimitMin := stForceLimitMinAtBeginn;		
			stForceLimitMin.fz := stForceLimitMin.Fz * fPowerFactor;
			stForceLimitMin.Mx := stForceLimitMin.Mx * fPowerFactor;
			stForceLimitMin.My := stForceLimitMin.My * fPowerFactor;
			
			stForceLimitMax := stForceLimitMaxAtBeginn;	
			stForceLimitMax.fz := stForceLimitMax.Fz * fPowerFactor;
			stForceLimitMax.Mx := stForceLimitMax.Mx * fPowerFactor;
			stForceLimitMax.My := stForceLimitMax.My * fPowerFactor;
	
			// 13.01.2025 Todo PLC Chash if Min > Max. use objParm insted
			//	THIS^.TcIoXPlanarMover.SetForceLimitMin(stForceLimitMin);
			//	THIS^.TcIoXPlanarMover.SetForceLimitMax(stForceLimitMax);
			FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
			IF ipComObject <> 0 THEN
				// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
				// The minimum is therefore first written to something valid. Followed by Max and the original minimum
				hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
				hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMax), pData := ADR(stForceLimitMax), pgp := 0);
				hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMin), pData := ADR(stForceLimitMin), pgp := 0);
				FW_SafeRelease(ADR(ipComObject));
			END_IF

	
		END_IF
	
		
	20: // Reduce Force to minimum
		fPowerFactor := fMinForceFactor;
		
		//set force Z, a and b to minimum
		stForceLimitMin := stForceLimitMinAtBeginn;		
		stForceLimitMin.fz := stForceLimitMin.Fz * fPowerFactor;
		stForceLimitMin.Mx := stForceLimitMin.Mx * fPowerFactor;
		stForceLimitMin.My := stForceLimitMin.My * fPowerFactor;
		
		stForceLimitMax := stForceLimitMaxAtBeginn;	
		stForceLimitMax.fz := stForceLimitMax.Fz * fPowerFactor;
		stForceLimitMax.Mx := stForceLimitMax.Mx * fPowerFactor;
		stForceLimitMax.My := stForceLimitMax.My * fPowerFactor;
	    
	    
		// 13.01.2025 Todo PLC Chash if Min > Max. use objParm insted
		//	THIS^.TcIoXPlanarMover.SetForceLimitMin(stForceLimitMin);
		//	THIS^.TcIoXPlanarMover.SetForceLimitMax(stForceLimitMax);
		FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
		IF ipComObject <> 0 THEN
			// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
			// The minimum is therefore first written to something valid. Followed by Max and the original minimum
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMax), pData := ADR(stForceLimitMax), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMin), pData := ADR(stForceLimitMin), pgp := 0);
			FW_SafeRelease(ADR(ipComObject));
		END_IF

		
		nSeqLowerToUnknown := 999;
				
	999: // finish seqence feedback
		fbFeedbackLowerToUnknown.Done := TRUE;
		
	1000..1999:
		//Error
		fbFeedbackLowerToUnknown.HR := E_FAIL;
END_CASE



//Up
CASE nSeqLiftFromUnknown OF
	0: //Wait for start
		;
		
	1: // Check if not already lifted	
		IF fPowerFactor = fMaxForceFactor THEN
			nSeqLiftFromUnknown := 999;
		ELSE
			nSeqLiftFromUnknown := 5;
		END_IF		
		
	5: 
		//0.0 - 1.0
		fPowerFactor := (stForcesAtBeginn.z / stForceLimitMaxAtBeginn.Fz);
		
		// -5%
		fPowerFactor := fPowerFactor - 0.05;
		
		//Limit to 0.1 - 1.0
		fPowerFactor := MIN(fPowerFactor, fMaxForceFactor);
		fPowerFactor := MAX(fPowerFactor, fMinForceFactor);
		
		//set force Z, a and b
		stForceLimitMin := stForceLimitMinAtBeginn;		
		stForceLimitMin.fz := stForceLimitMin.Fz * fPowerFactor;
		stForceLimitMin.Mx := stForceLimitMin.Mx * fPowerFactor;
		stForceLimitMin.My := stForceLimitMin.My * fPowerFactor;
		
		stForceLimitMax := stForceLimitMaxAtBeginn;	
		stForceLimitMax.fz := stForceLimitMax.Fz * fPowerFactor;
		stForceLimitMax.Mx := stForceLimitMax.Mx * fPowerFactor;
		stForceLimitMax.My := stForceLimitMax.My * fPowerFactor;

		// 13.01.2025 Todo PLC Chash if Min > Max. use objParm insted
		//THIS^.TcIoXPlanarMover.SetForceLimitMax(stForceLimitMax);
		//THIS^.TcIoXPlanarMover.SetForceLimitMin(stForceLimitMin);
		FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
		IF ipComObject <> 0 THEN
			// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
			// The minimum is therefore first written to something valid. Followed by Max and the original minimum
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMax), pData := ADR(stForceLimitMax), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMin), pData := ADR(stForceLimitMin), pgp := 0);
			FW_SafeRelease(ADR(ipComObject));
		END_IF
		
		nSeqLiftFromUnknown := 10;
		

		
	10: 	
		//A lift of the mover was detected followed by speed ~0
		IF (THIS^.PositionAct.z > THIS^.PositionSet.z * 0.5) AND (ABS(THIS^.VelocityAct.z) < 5.0)  THEN
			nSeqLiftFromUnknown := 20;
			
		ELSIF (fPowerFactor >= fMaxForceFactor ) THEN
			nSeqLiftFromUnknown := 20;
				
		ELSE
			//Reduce force each cycle
			fPowerFactor := fPowerFactor + ((fLiftNPerS/stForceLimitMaxAtBeginn.Fz) * fCycleTime_s);
					
			//Limit to 0.1 - 1.0
			fPowerFactor := MIN(fPowerFactor, fMaxForceFactor);
			fPowerFactor := MAX(fPowerFactor, fMinForceFactor);
			
			//set force Z, a and b 
			stForceLimitMin := stForceLimitMinAtBeginn;		
			stForceLimitMin.fz := stForceLimitMin.Fz * fPowerFactor;
			stForceLimitMin.Mx := stForceLimitMin.Mx * fPowerFactor;
			stForceLimitMin.My := stForceLimitMin.My * fPowerFactor;
			
			stForceLimitMax := stForceLimitMaxAtBeginn;	
			stForceLimitMax.fz := stForceLimitMax.Fz * fPowerFactor;
			stForceLimitMax.Mx := stForceLimitMax.Mx * fPowerFactor;
			stForceLimitMax.My := stForceLimitMax.My * fPowerFactor;
	
	
		// 13.01.2025 Todo PLC Chash if Min > Max. use objParm insted
		//THIS^.TcIoXPlanarMover.SetForceLimitMax(stForceLimitMax);
		//THIS^.TcIoXPlanarMover.SetForceLimitMin(stForceLimitMin);
		FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
		IF ipComObject <> 0 THEN
			// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
			// The minimum is therefore first written to something valid. Followed by Max and the original minimum
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMax), pData := ADR(stForceLimitMax), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMin), pData := ADR(stForceLimitMin), pgp := 0);
			FW_SafeRelease(ADR(ipComObject));
		END_IF
	
		END_IF
	
		
	20: // Reduce Force to normal			
		fPowerFactor := fMaxForceFactor;
		
		//set force Z, a and b to minimum
		stForceLimitMin := stForceLimitMinAtBeginn;		
		stForceLimitMin.fz := stForceLimitMin.Fz * fPowerFactor;
		stForceLimitMin.Mx := stForceLimitMin.Mx * fPowerFactor;
		stForceLimitMin.My := stForceLimitMin.My * fPowerFactor;
		
		stForceLimitMax := stForceLimitMaxAtBeginn;	
		stForceLimitMax.fz := stForceLimitMax.Fz * fPowerFactor;
		stForceLimitMax.Mx := stForceLimitMax.Mx * fPowerFactor;
		stForceLimitMax.My := stForceLimitMax.My * fPowerFactor;
	    	
		// 13.01.2025 Todo PLC Chash if Min > Max. use objParm insted
		//THIS^.TcIoXPlanarMover.SetForceLimitMax(stForceLimitMax);
		//THIS^.TcIoXPlanarMover.SetForceLimitMin(stForceLimitMin);
		FW_ObjMgr_GetObjectInstance(oid:= THIS^.UtilityTcIoMover.ObjectId, iid:= TC_GLOBAL_IID_LIST.IID_ITComObject, pipUnk:= ADR(ipComObject));
		IF ipComObject <> 0 THEN
			// No minimum can be set if one of the 6 values in the struct is greater than the maximum. Equal is allowed.
			// The minimum is therefore first written to something valid. Followed by Max and the original minimum
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stValideMinForce), pData := ADR(stValideMinForce), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMax, nData := SIZEOF(stForceLimitMax), pData := ADR(stForceLimitMax), pgp := 0);
			hr := ipComObject.TcSetObjPara(pid := N_PTCID_ForceLimitMin, nData := SIZEOF(stForceLimitMin), pData := ADR(stForceLimitMin), pgp := 0);
			FW_SafeRelease(ADR(ipComObject));
		END_IF
		
		
		THIS^.UtilityMcMover.SetMaximumPositionLagValue(stLagValuesAtBeginn);
        
		nSeqLiftFromUnknown := 999;
				
	999: // finish seqence feedback
		fbFeedbackLiftFromUnknown.Done := TRUE;
		
	1000..1999:
		//Error
		fbFeedbackLiftFromUnknown.HR := E_FAIL;
END_CASE


]]></ST>
      </Implementation>
    </Method>
    <Property Name="UtilityMcMover" Id="{cab4f1ac-f949-4b0f-9abb-2fd50f7eddd0}" FolderPath="XPlanarUtility\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY UtilityMcMover : Tc3_XPlanarUtility.I_McPlanarMover]]></Declaration>
      <Get Name="Get" Id="{43cd8752-c959-4b42-b896-ad915e653b55}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[UtilityMcMover :=  THIS^.ipMcMover;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="UtilityTcIoMover" Id="{8b11592d-c5fc-49f9-8ea2-4c230e1380b3}" FolderPath="XPlanarUtility\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY UtilityTcIoMover : Tc3_XPlanarUtility.I_TcIoXPlanarMover]]></Declaration>
      <Get Name="Get" Id="{94982195-fa79-480b-85bc-04315239c2d2}">
        <Declaration><![CDATA[VAR
;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[UtilityTcIoMover := THIS^.ipTcIoMover;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="VelocityAct" Id="{b149e020-d324-4301-8f41-ff44a56a3529}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Provides the current planar mover act XYZABC [mm/s] *)
PROPERTY VelocityAct : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{513d1962-a4a5-41e2-ac8b-a2a845e1f61b}">
        <Declaration><![CDATA[VAR_INST
	{attribute 'hide'}
	copyOfData :  MoverVector;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//Creat an copy of the struct to view value in targetdbrowser and plc online view
copyOfData := THIS^.fbMover.MCTOPLC.ACT.ActVelo;
VelocityAct REF= copyOfData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="VelocitySet" Id="{8ad10d00-a316-4798-b468-ed581c984c24}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
(* Provides the current planar mover setpoint XYZABC [mm/s] *)
PROPERTY VelocitySet : REFERENCE TO MoverVector]]></Declaration>
      <Get Name="Get" Id="{ef55facb-367e-465e-8abb-3e765ba606db}">
        <Declaration><![CDATA[VAR_INST
	{attribute 'hide'}
	copyOfData :  MoverVector;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//Creat an copy of the struct to view value in targetdbrowser and plc online view
copyOfData := THIS^.fbMover.MCTOPLC.SET.SetVelo;
VelocitySet REF= copyOfData;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>